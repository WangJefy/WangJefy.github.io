<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[条件渲染]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[v-if v-if指令用于条件性地渲染 一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染 The directive v-if is used to conditionally render a block. The block will only be rendered if the directives expression returns a truthy value 1234567&lt;h1 v-if="awesome"&gt; Vue is awesome!&lt;/h1&gt;&lt;!-- 也可用 v-else 添加一个 else 块 --&gt;&lt;h1 v-if="awesome"&gt; Vue is awesome &lt;/h1&gt;&lt;h1 v-else&gt;Oh no&lt;/h1&gt; 在&lt;template&gt; 元素上条件分组(Conditional Groups with v-if on &lt;template&gt; ) 因为 v-if 是一个指令，所以必须将它添加到一个元素上(Because v-if is a directive, it has to be attached to a single element)。 但是如果想切换多个元素呢？—— 此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if (In this case we can use v-if on a &lt;template&gt; element, which serves as an invisible wrapper)。最终的渲染结果将不包含 &lt;template&gt; 元素。 12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; Note: 最终的渲染结果，不会包含 &lt;template&gt; 元素。 v-else 你可以使用 v-else 指令来表示 v-if 的 else块： 1234567&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素后面，否则它将不会被识别。 v-else-if [V2.1.0新增] v-else-if，顾名思义，充当 v-if 的“else-if块”，可以连续使用： 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后 用key管理可复用的元素(Controlling Reusable Elements with key) Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染(Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch)。 在1中的做法，除了使Vue变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换： 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板(template)中使用了相同的元素(element)，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder。 但3中的做法也不总是符合实际需求，所以Vue提供了一种方式来表达”这两个元素时完全独立的，不要复用它们”。——只需添加一个具有唯一值的 key 特性(attribute)即可： 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; 现在，每次切换时，输入框都将被重新渲染。 注意：&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 特性(attributes)。 v-show 另外一个用于根据条件展示元素的选择是 v-show 指令。用法大致一样： 123&lt;h1 v-show="ok"&gt; Hello!&lt;/h1&gt; 与 v-if 不同的是，带有 v-show 的元素始终会被渲染并保留在DOM中 v-show 只是简单地切换元素的CSS属性 display v-show 不支持 template元素，也不支持 v-else v-if vs v-show v-if 是“真正”的条件渲染(conditional rendering)，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 是 惰性的 ：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 指令相对简单，不管初始条件时什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。 一般，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 v-show 适合非常频繁地切换情况；v-if 适合切换频率低的情况。 v-if 与 v-for 不推荐 同时使用 v-if 和 v-for ，请查阅风格指南以获取更多信息。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。请查阅 列表渲染指南 以获取详细信息。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class与Style绑定]]></title>
    <url>%2F2019%2F03%2F29%2FClass%E4%B8%8EStyle%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[操作元素的 class列表 和 内联样式 是数据绑定的一个常见需求。因为他们都是特性(attributes)，所以我们可以用 v-bind 处理他们——只需要通过表达式计算出 字符串结果 即可。 不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js做了专门的增强。表达式结果除了 字符串 之外，还可以是 对象 或 数组 绑定HTML Class(Binding HTML Classes)对象语法(Object Syntax) 我们可以给 v-bind:class 传一个对象，以动态地切换 class 123&lt;div v-bind:class="&#123; active: isActive &#125;"&gt; ...&lt;/div&gt; 在1中的例子里，语法表示 active 这个class存在与否将取决于数据属性 isActive 的布尔值(The above syntax means the presence of the active class will be determined by the truth of the data property isActive) 你可以在对象中传入更多属性来动态切换多个class。此外， v-bind:class 指令还可以与普通的class属性共存 12345&lt;div class = "static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt; ...&lt;/div&gt; 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 123&lt;div class="static active"&gt; ...&lt;/div&gt; 当 isActive 或者 hasError 变化时， class列表将相应地更新(When isActive or hasError changes, the class list will be updated accordingly)。例如，如果 hasError 的值为true时，class列表将变为 static active text-danger 绑定的数据的对象不必内联定义在模板里： 123&lt;div v-bind:class="classObject"&gt; ...&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 针对5，我们也可以在这里绑定一个返回对象的 计算属性 。这是一个常用且强大的模式： 123&lt;div v-bind:class="classObject"&gt; ...&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function()&#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 数组语法(Array Syntax) 我们可以向 v-bind:class 传一个 数组 ，构成class列表： 123&lt;div v-bind:class="[activeClass, errorClass]"&gt; ...&lt;/div&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 最终渲染为： 123&lt;div class="active text-danger"&gt; ...&lt;/div&gt; 如果你想根据条件切换列表中的class，可以用三元表达式： 1234&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt; ...&lt;/div&gt;&lt;!-- 这种写法将始终添加errorClass, 只在isActive为true时，才添加activeClass --&gt; 当有多个条件class时，上面这种写法有些繁琐，所以在数组语法中也可以使用对象语法： 123&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt; ...&lt;/div&gt; 用在组件上(With Components) 当在一个自定义的组件上使用 class 特性时，这些类将被添加到该组件的根元素上面(When you use the class attribute on a custom component，those classes will be added to the component’s root element)。这个根元素上已经存在的类不会被覆盖(Existing classes on this root element will not be overwritten)。 1234// 例如，如果你声明了这个组件Vue.component('my-component', &#123; template: '&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'&#125;) 12&lt;!-- 然后在使用它的时候添加一些 class --&gt;&lt;my-component class="baz boo"&gt; &lt;/my-component&gt; HTML将被渲染为： 123&lt;p class="foo bar baz boo"&gt; Hi&lt;/p&gt; 除了1中例子外，对于带数据绑定class同样适用： 123&lt;my-component v-bind:class="&#123; active: isActive &#125;"&gt; ...&lt;/my-component&gt; 当 isActive 为 truthy 时，HTML将被渲染成为： 123&lt;p class="foo bar active"&gt; Hi&lt;/p&gt; 绑定内联样式(Binding Inline Styles)对象语法(Object Syntax) v-bind:style 的对象语法十分直观。其中的CSS属性名(property names)可以用驼峰式(camelCase)或短横线分隔(kebab-case，记得用单引号括起来)来命名： 123&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt; ...&lt;/div&gt; 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个 样式对象 通常会更好，这会让模板更清晰： 123&lt;div v-bind:style="styleObject"&gt; ...&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 同样地，对象语法 常常结合 返回对象的 计算属性 使用。 数组语法(Array Syntax) v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 123&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt; ...&lt;/div&gt; 自动添加前缀(Auto-prefixing) 当 v-bind:style 使用需要添加 浏览器引擎前缀 的CSS属性时，如 transform ，Vue.js会自动侦测并添相应的前缀。 多重值(Multiple Values) [V2.3.0+新增] 从2.3.0起，你可以为 style 绑定中的属性提供一个包含多个值得数组，常用于提供多个带前缀的值，例如： 1234567&lt;div :style="&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"&gt; ...&lt;/div&gt;&lt;!-- 这样写只会渲染数组中最后一个被浏览器支持的值。 在本例中，如果浏览器支持不带浏览器前缀的flexbox, 那么就只会渲染 display: flex --&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算属性与侦听器]]></title>
    <url>%2F2019%2F03%2F28%2F%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[计算属性(Computed Properties) 模板内的表达式非常便利，但是设计他们的初衷是用于简单运算 在模板中放入太多的逻辑会让模板过重且难以维护 123&lt;div id="example"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 在2中，模板不再是简单的声明式逻辑。你必须看一段时间才能意思到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理——所以，对于任何复杂的逻辑，你都应当使用 计算属性 基础例子(Basic Example)123456&lt;div id="example"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt; Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;" &lt;/p&gt;&lt;/div&gt; 123456789101112131415var vm = new Vue(&#123; el: "#example", data: &#123; message: 'Hello' &#125;, computed:&#123; // 计算属性的getter. // English: a computed getter reversedMessage: function()&#123; // this 指向vm实例 // this points to the vm instance return this.message.split('').reverse().join(''); &#125; &#125;&#125;) 123Result:Original message: "Hello"Computed reversed message: "olleH" 在上面例子中，我们声明了一个计算属性 reversedMessage (Here we have declared a computed property reversedMessage )。我们提供的函数将用作属性 vm.reversedMessage 的getter函数(The function we provided will be used as the getter function for the property vm.reversedMessage)。 1234567console.log(vm.reversedMessage) // =&gt; 'olleH'vm.message = 'Goodbye'console.log(vm.reversedMessage) // =&gt; 'eybdooG'/**你可以打开浏览器的控制台，自行修改例子中的vm.vm.reversedMessage的值最终取决于vm.message的值*/ 你可以像绑定普通属性一样在模板中绑定计算属性(You can data-bind to computed properties in templates just like a normal property) Vue知道 vm.reversedMessage 依赖于 vm.message ，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。 而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。 计算属性缓存(Computed Caching) vs 方法(Methods) 我们可以通过在表达式中调用方法来达到同样的效果(We can achieve the same result by invoking a method in the expression)。 123&lt;p&gt; Reversed message: "&#123;&#123; reverseMessage() &#125;&#125;"&lt;/p&gt; 1234567// in component // 在组件中methods: &#123; reverseMessage: function()&#123; return this.message.split('').reverse().join(''); &#125;&#125; 我们可以将 同一函数 定义为 一个方法 而不是 一个计算属性 (Instead of a computed property, we can define the same function as a method instead)。这两种方式的最终结果确实是完全相同的(For the end result, the two approaches are indeed exactly the same) 然而，不同的是 计算属性是基于它们的响应式依赖进行缓存的( computed properties are cached based on their reactive dependencies) 。只在相关响应式依赖(reactive dependencies)发生改变时它们才会重新求值。这也意味着 只要message 还没有发生改变，多次访问reverseMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 12345computed: &#123; now: function()&#123; return Date.now() &#125;&#125; 相比计算属性，每当触发重新渲染时，调用方法将 总会 再次执行函数(In comparison, a method invocation will always run the function whenever a re-render happens) 123我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性(Computed) vs 侦听属性(Watch property) Vue.js提供了一种更加通用的方式来观察和响应Vue实例上的数据变动—— 侦听属性 (Vue does provide a more generic way to observe and react to data changes on a Vue instance: watch properties) 当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch ——特别是如果你之前使用过AngularJS 然而，通常更好的做法是使用计算属性而不是命令式 watch 回调(However it is often a better idea to use a computed property rather than an imperative watch callback) 123&lt;div id="demo"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt; 123456789101112131415161718var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function(val)&#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function(val)&#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;)// 上面的代码是命令式且重复的(The above code is imperative and repetitive)// 将上面代码与计算属性的版本进行比较 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: "Foo", lastName: "Bar" &#125;, computed: &#123; fullName: function()&#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 计算属性的setter(Computed Setter) 计算属性默认只有getter，不过在需要时你可以提供一个setter： 12345678910111213141516171819// ...computed: &#123; fullName: &#123; // getter get: function()&#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function(newValue)&#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;/** 现在再运行 vm.fullName = 'John Doe' 时，setter会被调用 vm.firstName 和 vm.lastName 也会相应地被更新*/ 侦听器(Watchers) 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时 执行异步 或 开销较大的操作 时，侦听器方式最有用 12345678910&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt; &#123;&#123; answer &#125;&#125; &lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复提供这些功能以保持精简。 这也可以让你自由选择自己更熟悉的工具 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt; var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer util you ask a question' &#125;, // 侦听器 watch:&#123; // 如果 question 发生改变，这个函数就会执行 question: function(newQuestion, oldQuestion)&#123; this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() &#125; &#125;, // 钩子函数 created: function()&#123; // _.debounce 是一个通过Lodash限制操作频率的函数 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // AJAX 请求直到用户输入完毕才会发出 // 想要了解更多关于 _.debounce的函数(以及其近亲 _.throttle)的知识 // 请参考： https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, // 方法 methods: &#123; getAnswer: function()&#123; if(this.question.indexOf('?') === -1 )&#123; this.answer = 'Questions usually contain a question mark.' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function(response)&#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function(error)&#123; vm.answer = 'Error~Could not reach the API ' + error &#125;) &#125; &#125; &#125;)&lt;/script&gt; 在2中的示例里，使用 watch 选项允许我们执行异步操作(访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果之前，设置中间状态。这些都是计算属性无法做到的。 除了 watch 选项之外，您还可以使用命令式(imperative)的 vm.$watch API 本文小结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板语法]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue.js 使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定在底层Vue实例的数据上。(Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data) 所有Vue.js 的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。(All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers) 在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。(Under the hood, Vue compiles the templates into Virtual DOM render functions)，并结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。(Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes) 如果你熟悉虚拟DOM并且偏爱JavaScript的原始力量，你也可以不用模板，直接写渲染函数(render)函数 ，使用可选的JSX语法。 插值(Interpolations)文本(Text)插值 数据绑定最常见的形式就是使用 Mustache语法-双大括号 的文本插值。 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值(The mustache tag will be replaced with the value of the msg property on the corresponding data object)。无论何时，绑定的数据对象上 msg 属性发生改变，插值处的内容都会更新(It will also be updated whenever the data objects’s msg property changes) 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新(You can also perform one-time interpolations that do not update on data change by using the v-once directive)。但请留心这会影响到该节点上的其他数据绑定： 1&lt;span v-once&gt;这个将不会改变： &#123;&#123; msg &#125;&#125;&lt;/span&gt; 原始HTML(Raw HTML)插值 Mustache语法-双大括号会将数据解释为普通文本，而非HTML代码 为了输出真正的HTML，你需要使用 v-html 指令 12345&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt; Using v-html directives: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 12Using mustaches: &lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;Using v-html directive: This should be red. 在2中的例子里，span 的内容将会替换为属性值 rawHtml ，直接作为HTML——这会忽略解析属性值中的数据绑定(The contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored) 注意，你不能使用 v-html 来构造模板部分，因为Vue不是基于字符串的模板引擎(Note that you cannot use v-html to compose template partials, because Vue isn’t a string-based templating engine)。相反对于用户界面，组件才更适合作为可重用和可组合的基本单位(Instead, components are preferred as the fundamental unit for UI reuse and composition)。 在站点上动态渲染的任意HTML可能会非常危险，因为它很容易导致XSS攻击。请只对可信内容使用HTML插值，绝不要对用户提供的内容使用HTML插值。(Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content.) 特性(Attributes)插值 Mustaches 语法不能作用在HTML特性上(Mustaches cannot be used inside HTML attributes)。遇到这种情况，应该使用 v-bind 指令： 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 在布尔特性的情况下，它们的存在即暗示为 true ，v-bind 工作起来略有不同(In the case of boolean attributes, where their mere existence implies true ，v-bind works a little differently) 1&lt;button v-bind:disabled="isButtonDisabled"&gt;Button&lt;/button&gt; 如果2中 isButtonDisabled 的值是 null、undefined 或者 false，则disabled 特性甚至不会被包含在渲染出来的 &lt;button&gt;元素中(If isButtonDisabled has the value of null, undefined, or false, the disabledattribute will not even be included in the rendered &lt;button&gt; element)。 JavaScript表达式插值 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值(So far we’ve only been binding to simple property keys in our templates) 但实际上，对于所有的数据绑定，Vue.js 都提供了完全的JavaScript表达式支持(But Vue.js actually supports the full power of JavaScript expressions inside all data bindings) 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO'&#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 这些表达式会在所属Vue实例的数据作用域下作为JavaScript被解析(These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance) 有个限制就是，每个绑定都 只能包含单个表达式 (One restriction is that each binding can only contain one single expression)。所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125; &lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如Math 和 Date (Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date)。你不应该在模板表达式中试图访问用户定义的全局变量( You should not attempt to access user defined globals in template expressions)。 指令(Directives) 指令(Directives)是带有 v- 前缀的特殊特性(special attributes) 指令特性的值预期是 单个JavaScript表达式 ( v-for 是例外情况) 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM 1234&lt;p v-if="seen"&gt; 现在你可以看到我了&lt;/p&gt;&lt;!-- 这里，v-if 指令将根据表达式seen的值的真假来插入/移除&lt;p&gt;元素 参数(Arguments) 一些指令能够接收一个“参数”， 在指令名称之后以冒号表示 如 v-bind 指令可以用于响应式地更新HTML特性： 123&lt;a v-bind:href="url"&gt; ... &lt;/a&gt; 在2中，href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url的值绑定。 如 v-on 指令，它用于监听DOM事件 123&lt;a v-on:click="doSomething"&gt; ... &lt;/a&gt; 在4中，click 作为监听的事件名是参数 动态参数(Dynamic Arguments) [V2.6.0新增] 从2.6.0开始，可以用 方括号[] 括起来的JavaScript表达式作为一个指令的参数： 123&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt; 在1中的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，结果会作为最终的参数来使用。 例如，如果你的Vue实例有一个 data 属性 attributeName ，其值为 href，那么这个绑定将等价于 v-bind:href 。 同样地，你可以使用动态参数作为一个动态的事件名绑定处理函数(Similarly, you can use dynamic arguments to bind a handler to a dynamic event name) 1234&lt;a v-on:[eventName]="doSomething"&gt; ... &lt;/a&gt;&lt;!-- 当eventName的值为focus时，v-on:[eventName]将等价于v-on:focus 对动态参数值的约束(Value Constraints) 动态参数预期会求出一个字符串，异常情况下值为 null 这个特殊的 null 值可以被显性地用于移除绑定 任何其它非字符串类型的值都将会触发一个警告 对动态参数表达式的约束(Expression Constraints) 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。 同样，在DOM中使用模板时，你需要回避大写键名 12345&lt;!-- 下面的代码就是无效的 --&gt;&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:['foo' + bar]="value"&gt; ... &lt;/a&gt; 变通的方法是使用没有 空格 或 引号 的表达式，或者使用 计算属性(computed property) 替代这种复杂表达式。 如果你在DOM中使用模板(直接在一个HTML文件里撰写模板)，需要留意浏览器会把 特性名(Attribute Name) 全部强制转为小写: 1234&lt;!-- 在DOM中使用模板时这段代码会被转换为 v-bind:[someattr] --&gt;&lt;a v-bind:[someAttr]="value"&gt; ... &lt;/a&gt; 修饰符(Modifiers) 修饰符(Modifiers)是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊的方式绑定(Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way) 比如， .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() 123&lt;form v-on:submit.prevent="onSubmit"&gt; ...&lt;/form&gt; 在后续对 v-on 和 v-for 等功能的探索中，你会看到修饰符的其他例子 缩写(Shorthands) v- 前缀作为一种视觉提示，用来识别模板中Vue特定的特性(The v- prefix serves as a visual cue for identifying Vue-specific attributes in your templates) 当你在使用Vue.js为现有标签添加动态行为(dynamic behavior)时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到繁琐。 在构建由Vue管理所有模板的 单页面应用程序(SPA - Single Page Application) 时，v-on 前缀也会变得没那么重要 综上，Vue就为 v-bind 和 v-on 这两个最常用的指令，提供了特定的简写。 v-bind缩写12345&lt;!-- 完整写法 --&gt;&lt;a v-bind:href="url"&gt; ... &lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt; ... &lt;/a&gt; v-on缩写12345&lt;!-- 完整写法 --&gt;&lt;a v-on:click="doSomething"&gt; ... &lt;/a&gt; &lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt; ... &lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于特性名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Instance]]></title>
    <url>%2F2019%2F03%2F22%2FVue-Instance%2F</url>
    <content type="text"><![CDATA[新建实例(Creating a Vue Instance) 每个Vue应用都是通过用 Vue 函数创建一个新的Vue实例开始的。 123var vm = new Vue(&#123; // 选项&#125;) 当创建一个Vue实例时，可以传入一个选项对象(options object)。而如何使用这些选项来创建你想要的行为，正是该文档的核心内容。完整的选项列表可参考 API文档。 一个Vue应用由一个通过 new Vue 创建的 根Vue实例(root Vue instance) ，以及可选的、嵌套的、可复用的组件树组成。(A Vue application consists of a root Vue instance created with new Vue , optionally organized into a tree of nested, reusable components) 12345678根实例└─ TodoList ├─ TodoItem │ ├─ DeleteTodoButton │ └─ EditTodoButton └─ TodoListFooter ├─ ClearTodosButton └─ TodoListStatistics 所有的Vue组件都是Vue实例，并且接受相同的选项对象(一些根实例特有的选项除外)(All Vue components are also Vue instance, and so accept the same options object [except for a few root-specific options]) 数据与方法(Data and Methods) 当一个Vue实例被创建时，它向Vue的 响应式系统(reactivity system) 中加入了其 data 对象中能找到的所有属性。 这些属性的值发生变化时，视图会匹配更新为新的值 12345678910111213141516171819// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个Vue实例中var vm = new Vue(&#123; data: data&#125;)// 获得这个实例上的属性// 返回源数据中对应的字段vm.a === data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// 反之亦然data.a = 3vm.a // =&gt; 3 只有当实例被创建时 data 中存在的属性才是 响应式(reactive) 的，才能在数据改变时，重新渲染视图。也就是说 如果你添加一个新的属性(property)，比如 123456789101112vm.b = 'hi'/**那么对b的改动将不会触发任何视图的更新。如果你知道你会在晚些时候，需要这个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值就可。*/data:&#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 在1/2/3中唯一的例外是使用 Object.freeze() ，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 1234567&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 foo 不会更新 --&gt; &lt;button v-on:click="foo = 'bazz'"&gt; Change it &lt;/button&gt;&lt;/div&gt; 12345678910var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;) 除了1/2/3/4详述的 数据属性(data properties) ，Vue实例还暴露了一些有用的实例属性和方法，它们都有前缀 $ ，以便与用户定义的属性区分开来。完整的实例属性和方法列表看参考 API文档 12345678910111213var data = &#123; a: 1&#125;var vm = new Vue(&#123; el: "#example", data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function(newValue, oldValue)&#123; // 这个回调将在 vm.a 变化后调用&#125;) 实例生命周期钩子(Instance Lifecycle Hooks) 每个Vue实例在被创建时都要经过一系列的初始化过程(a series of initialization steps) 这个过程包含 设置数据监听(set up data observation)、编译模板(compile the template)、将实例挂载到DOM(mount the instance to the DOM)、并在数据变化时更新DOM等(update the DOM when data changes) 同时在这个过程中也会运行一些叫做 生命周期钩子(Lifecycle Hooks) 的函数，给了用户在不同阶段添加自定义代码的机会。 123456789101112// 比如 `created` 钩子可以用来在一个实例被创建之后执行代码new Vue(&#123; data: &#123; a: 1 &#125;, // 用于在实例被创建之后执行代码 created: function()&#123; // *this 指向vm实例（以后出现 vm 都表示Vue实例 console.log('a is: ' + this.a ) &#125;&#125;)// =&gt; "a is: 1" 除了3提到的 created 钩子，还有 mounted 、 updated 和 destroyed 等会在实例生命周期的不同阶段被调用。 生命周期钩子的 this 上下文指向调用它的Vue实例(All lifecycle hooks are called with thier this context pointing to the Vue instance invoking it.) 非常重要的点如下 123456789Note: 不要在选项属性或回调函数上使用箭头函数(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)(Don&apos;t use arrow functions on an options property or callback)。比如 `created: () =&gt; console.log(this.a)` 或 `vm.$watch(&apos;a&apos;, newValue =&gt; this.myMethod())`因为箭头函数并没有`this`, `this`会作为变量一直向上词法作用域查找，直到找到位置，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。 生命周期图示]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门]]></title>
    <url>%2F2019%2F01%2F08%2Fvue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基本定义在Vue.js的官方文档中是这样定义的： Vue是一套用于构建用户界面的渐进式框架(Vue is a progressive framework for building user interfaces) Vue被设计为可以自底而上逐层应用(Vue is designed from the ground up to be incrementally adoptable) Vue的核心库只关注视图层(The core library is focused on the view layer only) 核心功能一、声明式渲染(Declarative Rendering)Vue的核心是一个允许采用简洁模板语法来声明式地将数据渲染进DOM系统(A system that enables us to declaratively render data to the DOM using straightforward template syntax) 这里就引出了前端框架中最为常用的双向绑定，建立数据(可以是JavaScript Object，JSON，字符串或其他格式的数据)与DOM间的绑定。绑定的信息有以下几种： 文本插值(Text Interpolation) Example - 1: 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: "#app", data: &#123; message: "Hello Vue" &#125;&#125;) Example - 2: 1234&lt;div id="app2"&gt; &lt;!-- 时间过滤器 --&gt; &#123;&#123; dateDDD | formatDate &#125;&#125;&lt;/div&gt; 12345678910111213import &#123;formatDate&#125; from "../js/date.js"var app2 = new Vue(&#123; el: "#app2", data: &#123; dateDDD: new Date() &#125;, filters: &#123; formatDate( time )&#123; let date = new Date(time); return formatDate(date, 'yyyy-MM-dd hh:mm'); &#125; &#125;&#125;) 1234567891011121314151617181920212223/** 保存在js文件下的data.js文件 */export function formatDate(date, fmt) &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) &#125; let o = &#123; 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() &#125; for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; let str = o[k] + '' fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str) &#123; return ('00' + str).substr(str.length)&#125; 元素特性(Element Attributes) 1234&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt;鼠标悬停就可查看动态绑定的提示信息&lt;/span&gt; &lt;!--此处指令是将这个元素节点的title属性和Vue实例的message属性保持一致--&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: "#app-2", data: &#123; message: '页面加载于' + new Date().toLocaleString() &#125;&#125;) Note: 代码块中v-bind特性被称为指令(The v-bind attribute you are seeing is called a directive)；指令带有前缀v- 用来表示它们是Vue提供的特殊特性，会在渲染的DOM上应用特殊的响应式行为。 DOM结构(The structure of the DOM) Example - 1: 12345&lt;div id="app-3"&gt; &lt;p v-if="seen"&gt; 现在你看到我了 &lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: "#app-3", data: &#123; seen: true &#125;&#125;) Example - 2: 12345&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: "#app-4", data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue.js' &#125;, &#123; text: '学习 牛项目' &#125; ] &#125;&#125;) 过渡效果 Vue提供了一个强大的过渡效果系统，可以在Vue 插入/更新/移除元素时自动应用 过渡效果。这里先按下不提。 事件监听器 为了让用户和你的应用进行交互，常用v-on 指令添加一个事件监听器 。通过该事件监听器 调用在Vue实例中定义的方法。 12345678&lt;div id="app-5"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt; 逆转消息 &lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: "#app-5", data: &#123; message: 'Hello Vue.js' &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) Note: 在 reverseMessage 方法中，更新了应用的状态，但没有触碰DOM(Update the state of our app without touching the DOM)。所有的DOM操作都由Vue来处理，我们编写代码时只需关注逻辑层面即可。 表单输入 Vue提供了 v-model 指令，可轻松实现表单输入和应用状态之间的双向绑定(Makes two-way binding between form input and app state a breeze) 123456&lt;div id="app-6"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: "#app-6", data: &#123; message: "Hello Vue" &#125;&#125;) 二、组件化应用构建(Composing with Components)组件系统是Vue的另一个重要概念，因为它是一种逻辑抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。如下图，几乎任意类型的应用界面都可以抽象为一个组件树： 组件定义在Vue里，一个组件本质上是一个拥有预定义选项的一个Vue实例。在Vue中注册组件很简单： 1234// 定义名为 todo-item 的新组件Vue.component('todo-item', &#123; template: '&lt;li&gt;这是一个待办项&lt;/li&gt;'&#125;) 现在可以用它构建另一个组件模板： 1234&lt;ol&gt; &lt;!-- 创建一个 todo-item 组件实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; 但是 上述做法会为每个待办项渲染同样的文本，这看起来并不炫酷。最好的做法是 应该能从父作用域将数据传到子组件才对。因此我们将修改一下组件的定义，使之能接受一个 prop ： 1234567891011&lt;div id="app-7"&gt; &lt;ol&gt; &lt;!--现在我们为每个 todo-item 提供 todo 对象，todo对象是变量，其内容是可变的。 同时我们需要为每个组件提供一个 "key"，稍后再作详细解释--&gt; &lt;todo-item v-for="item in groceryList" v-bind:todo="item" v-bind:key="item.id" &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910111213141516171819Vue.component('todo-item', &#123; /** todo-item 组件现在接受一个 prop，类似于一个自定义特性 这个 prop 名为 todo */ props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: '蔬菜' &#125;, &#123; id: 1, text: '奶酪' &#125;, &#123; id: 2, text: '土豆' &#125; ] &#125;&#125;) 尽管上面只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元，子单元通过 props 接口与父单元进行了良好的解耦(The child is reasonably well-decoupled from the parent via the props interface) 接下来的介绍中，我们可以进一步改进 &lt;todo-item&gt; 组件，提供更为复杂的模板和逻辑，而不影响到父单元。 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。 在后续教程中，我们将详细介绍组件，此处有一个例子用来展示使用了组件的应用模板是什么样： 1234567&lt;div id="app"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; 组件与自定义元素自定义元素时Web规范的一部分，Vue组件非常类似自定义元素，正是因为Vue的组件语法部分参考了该规范。比如Vue组件实现了Slot API 与 is 特性。但两者还是有几个关键差别： Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前Safari 10.1+、Chrome 54+和Firefox 63+原生支持Web Components。相比之下，Vue组件不需要任何polyfill，并且在所有支持的浏览器(IE9 及更高版本)之下表现一致。必要时，Vue组件也可包装于原生自定义元素之内。 The Web Components Spec has been finalized, but is not natively implemented in every browser. In comparison, Vue components don’t require any polyfills and work consistently in all supported browsers(IE9 and above), When needed, Vue components can also be wrapped inside a native custom element. Vue组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。 Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文备注]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%86%99%E6%96%87%E5%A4%87%E6%B3%A8%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20hello-world%2F</url>
    <content type="text"><![CDATA[本博客使用Hexo搭建完成~ 快速入门创建新文章1$ hexo new "My New Post" 启动本地服务1$ hexo server 生成静态文件1$ hexo generate 部署到远程服务器1$ hexo deploy 访问打开浏览器，输入 https://wangjefy.github.io/]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
