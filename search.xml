<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vue入门]]></title>
    <url>%2F2019%2F01%2F08%2Fvue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Vue的定义在Vue.js的官方文档中是这样定义的： Vue是一套用于构建用户界面的渐进式框架(Vue is a progressive framework for building user interfaces) Vue被设计为可以自底而上逐层应用(Vue is designed from the ground up to be incrementally adoptable) Vue的核心库只关注视图层(The core library is focused on the view layer only) 核心功能声明式渲染(Declarative Rendering)Vue的核心是一个允许采用简洁模板语法来声明式地将数据渲染进DOM系统(A system that enables us to declaratively render data to the DOM using straightforward template syntax) 这里就引出了前端框架中最为常用的双向绑定，建立数据(可以是JavaScript Object，JSON，字符串或其他格式的数据)与DOM间的绑定。绑定的信息有以下几种： 文本插值(Text Interpolation) Example - 1: 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: "#app", data: &#123; message: "Hello Vue" &#125;&#125;) Example - 2: 1234&lt;div id="app2"&gt; &lt;!-- 时间过滤器 --&gt; &#123;&#123; dateDDD | formatDate &#125;&#125;&lt;/div&gt; 12345678910111213import &#123;formatDate&#125; from "../js/date.js"var app2 = new Vue(&#123; el: "#app2", data: &#123; dateDDD: new Date() &#125;, filters: &#123; formatDate( time )&#123; let date = new Date(time); return formatDate(date, 'yyyy-MM-dd hh:mm'); &#125; &#125;&#125;) 1234567891011121314151617181920212223/** 保存在js文件下的data.js文件 */export function formatDate(date, fmt) &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) &#125; let o = &#123; 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() &#125; for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; let str = o[k] + '' fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str) &#123; return ('00' + str).substr(str.length)&#125; 元素特性(Element Attributes) 1234&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt;鼠标悬停就可查看动态绑定的提示信息 &lt;/span&gt; &lt;!--此处指令是将这个元素节点的title属性和Vue实例的message属性保持一致--&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: "#app-2", data: &#123; message: '页面加载于' + new Date().toLocaleString() &#125;&#125;) Note: 代码块中v-bind特性被称为指令(The v-bind attribute you are seeing is called a directive)；指令带有前缀v- 用来表示它们是Vue提供的特殊特性，会在渲染的DOM上应用特殊的响应式行为。 DOM结构(The structure of the DOM) Example - 1: 12345&lt;div id="app-3"&gt; &lt;p v-if="seen"&gt; 现在你看到我了 &lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: "#app-3", data: &#123; seen: true &#125;&#125;) Example - 2: 12345&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: "#app-4", data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue.js' &#125;, &#123; text: '学习 牛项目' &#125; ] &#125;&#125;) 过渡效果 Vue提供了一个强大的过渡效果系统，可以在Vue 插入/更新/移除元素时自动应用 过渡效果。 这里先按下不提 事件监听器 为了让用户和你的应用进行交互，常用v-on 指令添加一个事件监听器 。通过该事件监听器 调用在Vue实例中定义的方法。 12345678&lt;div id="app-5"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt; 逆转消息 &lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: "#app-5", data: &#123; message: 'Hello Vue.js' &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) Note: 在 reverseMessage 方法中，更新了应用的状态，但没有触碰DOM(Update the state of our app without touching the DOM)。所有的DOM操作都由Vue来处理，我们编写代码时只需关注逻辑层面即可。 表单输入 Vue提供了 v-model 指令，可轻松实现表单输入和应用状态之间的双向绑定(Makes two-way binding between form input and app state a breeze) 123456&lt;div id="app-6"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: "#app-6", data: &#123; message: "Hello Vue" &#125;&#125;) 组件化应用构建(Composing with Components)组件系统是Vue的另一个重要概念，因为它是一种逻辑抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。如下图，几乎任意类型的应用界面都可以抽象为一个组件树： 在Vue里，一个组件本质上是一个拥有预定义选项的一个Vue实例。在Vue中注册组件很简单： 1234// 定义名为 todo-item 的新组件Vue.component('todo-item', &#123; template: '&lt;li&gt;这是一个待办项&lt;/li&gt;'&#125;) 现在可以用它构建另一个组件模板： 1234&lt;ol&gt; &lt;!-- 创建一个 todo-item 组件实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; 但是 上述做法会为每个待办项渲染同样的文本，这看起来并不炫酷。最好的做法是 应该能从父作用域将数据传到子组件才对。因此我们将修改一下组件的定义，使之能接受一个 prop ： 12345678&lt;div id="app-7"&gt; &lt;ol&gt; &lt;!-- 现在我们为每个 todo-item 提供 todo 对象，todo对象是变量，其内容是可变的。 同时我们需要为每个组件提供一个 "key"，稍后再作详细解释 --&gt; &lt;/ol&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文备注]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%86%99%E6%96%87%E5%A4%87%E6%B3%A8%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20hello-world%2F</url>
    <content type="text"><![CDATA[本博客使用Hexo搭建完成~ 快速入门创建新文章1$ hexo new "My New Post" 启动本地服务1$ hexo server 生成静态文件1$ hexo generate 部署到远程服务器1$ hexo deploy 访问打开浏览器，输入 https://wangjefy.github.io/]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
