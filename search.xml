<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[组件注册(Component Registration)]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%2F</url>
    <content type="text"><![CDATA[组件名(Component Names)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组件基础(Components Basics)]]></title>
    <url>%2F2019%2F04%2F07%2F%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[基本示例这里有一个Vue组件的示例： 123456789// 定义一个名为 button-counter 的新组件Vue.component('button-counter', &#123; data: function()&#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click="count++"&gt;You clicked me &#123;&#123; count &#125;&#125;'&#125;) 组件 是 可复用的 Vue 实例(reusable Vue instance)，且带有一个名字 在上面这个例子中，组件名 是 &lt;button-counter&gt; 我们可以在一个 通过 new Vue 创建的 Vue根实例 中，把这个组件作为自定义元素来使用： 123&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 123new Vue(&#123; el: '#components-demo'&#125;) 因为组件是 可复用的 Vue实例，所以它们与new Vue接收相同的选项。 例如 data computed watch methods 以及生命周期钩子等 仅有的例外是 像el 这样 根实例特有的选项 组件的复用(Reusing Components)你可以将组件进行任意次数的复用： 12345&lt;div id="components-demo"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 12注意：当点击按钮时，每个组件都会 各自独立 维护它的count。因为你每用一次组件，就会有一个它的新的 实例 被创建。 data必须是一个函数 当我们定义这个 &lt;button-counter&gt; 组件时，你可能会发现它的 data 并不是像这样直接提供一个对象： 123data: &#123; count: 0&#125; 取而代之的是， 一个组件的data选项必须是一个函数，因此每个实例可以维护一份被返回对象的独立的拷贝： 12345data: function()&#123; return &#123; count: 0 &#125;&#125; 如果Vue没有这条规则，点击一个按钮，就可能会像如下代码一样影响到其他 所有实例。 组件的组织(Origanizing Components)通常一个应用 会以一棵嵌套的组件树的形式来组织： 例如，你可能会有页头、侧边栏、内容区等组件，每个组件又包含了其它的像导航链接、博文之类的组件。 为了能在模板中使用(To use these components in templates)，这些组件必须 先注册 以便Vue能够识别。 组件有两种注册类型：全局注册global 和 局部注册local。 1234// 通过 Vue.component 全局注册Vue.component('my-component-name',&#123; // ... options ...&#125;) 全局注册的组件 可以用在其被注册后的任何（通过 new Vue）创建的Vue根实例，也包括其组件树中的所有子组件的模板中。 通过Prop向子组件传递数据(Passing Data to Child Components with Props) 早些时候，我们提到了创建一个博文组件的事情。问题是如果你不能向这个组件传递某一篇博文的标题或内容之类的我们想展示的数据的话，它是没有办法使用的。这也正是 prop 的由来。 Prop是你可以在组件上注册的一些自定义特性(custom attributes)。 当一个值传递给一个 prop 特性的时候，它就变成了那个组件实例的一个属性(When a value is passed to a prop attribute, it becomes a property on that component instance) 12345678910111213141516171819202122// Father components&lt;template&gt; &lt;div id="components-demo"&gt; &lt;button-counter :childData="faultName"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import ButtonCounter from './ButtonCounter' export default&#123; name: 'Second', data()&#123; return &#123; faultName: 'apple' &#125; &#125;, components:&#123; ButtonCounter &#125; &#125;&lt;/script&gt; 12345678910111213141516171819202122232425262728293031323334// Son Component&lt;template&gt; &lt;div&gt; &lt;button v-on:click='count++'&gt; You clicked me &#123;&#123; count &#125;&#125; &lt;/button&gt; &lt;!-- 当一个值 传递给一个 prop特性的时候，它就变成了该组件实例的一个属性 --&gt; &lt;p&gt; &#123;&#123; childData &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default&#123; name: 'ButtonCounter', data()&#123; return &#123; count: 0 &#125; &#125;, props: &#123; // 当一个值 传递给一个 prop特性的时候，它就变成了该组件实例的一个属性 'childData': &#123; type: String, default: '' &#125; &#125; /** 或者 props:['childData'] */ &#125;&lt;/script&gt; 1234Vue.component('blog-post', &#123; props: ['title'], template: '&lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;'&#125;) 一个组件默认可以拥有任意数量的 prop，任何值都可以传递给任何 prop 在上述模板中，你会发现我们能够在组件实例中访问这个值，就像访问 data 中的值一样。 一个prop被注册后(Once a prop is registered)，你就可以像下面这样把数据作为一个自定义特性传递进来： 123&lt;blog-post title="My journey with Vue"&gt;&lt;/blog-post&gt;&lt;blog-post title="Blogging with Vue"&gt;&lt;/blog-post&gt;&lt;blog-post title="Why Vue is so fun"&gt;&lt;/blog-post&gt; 然而在一个典型的应用中，你可能在 data 里有一个博文数组： 12345678910new Vue(&#123; el: '#blog-post-demo', data: &#123; posts: [ &#123;id: 1, title: "My journey with Vue"&#125;, &#123;id: 2, title: "Blogging with Vue"&#125;, &#123;id: 3, title: "Why Vue is so fun"&#125; ] &#125;&#125;) 当你想要为每篇博文渲染一个组件： 12345&lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title"&gt;&lt;/blog-post&gt; 12345如上所示，你会发现我们可以使用 v-bind 来动态传递 prop。这在你一开始不清楚要渲染的具体内容，比如从一个 API 获取博文列表的时候，是非常有用的。到目前为止，关于 prop 你需要了解的大概就这些了，如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把 prop 读完。 单个根元素(A single Root Element) 当构建一个 &lt;blog-post&gt; 组件时，你的模板最终会包含的东西远不止一个标题： 123&lt;h3&gt; &#123;&#123; title &#125;&#125;&lt;/h3&gt; 最最起码，你会包含这篇博文的正文： 123456&lt;h3&gt; &#123;&#123; title &#125;&#125;&lt;/h3&gt;&lt;div v-html="content"&gt; &lt;/div&gt; 然而如果你在模板中尝试这样写，Vue会显示一个错误，并解释 every component must have a single root element(每个组件必须只有一个根元素)。 你可以将模板的内容包裹在一个父元素内，来修复这个问题，例如： 12345678&lt;div class="blog-post"&gt; &lt;h3&gt; &#123;&#123; title &#125;&#125; &lt;/h3&gt; &lt;div v-html="content"&gt; ... &lt;/div&gt;&lt;/div&gt; 看起来当组件变得越来越复杂的时候，我们的博文不只需要 标题 和 内容，还需要发布日期、评论等等。 为每个相关信息定义一个prop会变得很麻烦： 12345678&lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:title="post.title" v-bind:content="post.content" v-bind:publishedAt="post.publishedAt" v-bind:comments="post.comments"&gt;&lt;/blog-post&gt; 1234567所以是时候重构一下这个 &lt;blog-post&gt; 组件了，让它变成接受一个单独的 post prop：&lt;blog-post v-for=“post in posts" v-bind:key="post.id" v-bind:post="post"&gt;&lt;/blog-post&gt; 123456789101112131415Vue.component('blog-post', &#123; props: ['post'], template:` &lt;div class="blog-post"&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;div v-html="post.content"&gt;&lt;/div&gt; &lt;/div&gt; `&#125;)/**上述的这个和一些接下来的示例使用了 JavaScript 的[模板字符串](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Template_literals)来让多行的模板更易读。它们在 IE 下并没有被支持，所以如果你需要在不 (经过 Babel 或 TypeScript 之类的工具) 编译的情况下支持 IE，请使用[折行转义字符](https://css-tricks.com/snippets/javascript/multiline-string-variables-in-javascript/)取而代之。*/ 现在，不论何时为 post 对象添加一个新的属性，它都会自动地在&lt;blog-post&gt;内可用 监听子组件事件(Listening to Child Components Events) 我们开发 &lt;blog-post&gt; 组件时，它的一些功能可能要求我们和父级组件进行沟通。 例如我们可能会引入一个可访问性的功能来放大博文的字号，同时让页面的其它部分保持默认字号 Step 1：在其父组件中，我们可以通过添加一个 postFontSize 数据属性来支持这个功能： 1234567new Vue(&#123; el: '#blog-posts-events-demo', data: &#123; posts: [/* ... */], postFontSize: 1 &#125;&#125;) 12345678910&lt;!-- 它可以在模板中用来控制所有博文的字号 --&gt;&lt;div id="blog-posts-events-demo"&gt; &lt;div :style="&#123; fontSize: postFontSize + 'em' &#125;"&gt; &lt;blog-post v-for="post in posts" v-bind:key="post.id" v-bind:post="post" &gt;&lt;/blog-post&gt; &lt;/div&gt;&lt;/div&gt; Step 2：现在我们在每篇博文正文之前添加一个按钮来放大字号： 123456789101112Vue.component('blog-post', &#123; props: ['post'], template: ` &lt;div class="blog-post"&gt; &lt;h3&gt;&#123;&#123; post.title &#125;&#125;&lt;/h3&gt; &lt;button&gt; Enlarge text &lt;/button&gt; &lt;div v-html="post.content"&gt;&lt;/div&gt; &lt;/div&gt; `&#125;) 此时，会出现一个问题：这个按钮不会做任何事： 123&lt;button&gt; Enlarge text&lt;/button&gt; 当点击这个按钮时，我们需要告诉 父级组件 放大所有博文的文本。 幸好Vue实例提供了一个自定义事件的系统来解决这个问题。 父级组件 可以像处理native DOM事件一样通过 v-on 监听 子组件实例的任意事件： 12345&lt;blog-post ... v-on:enlarge-text="postFontSize += 0.1" &gt;&lt;/blog-post&gt; 同时 子组件 可以通过调用内建的 $emit 方法并传入 事件名称 来触发一个事件(emit an event)： 123&lt;button v-on:click="$emit('enlarge-text')"&gt; Enlarge text&lt;/button&gt; 或者： 123&lt;button v-on:click="enlarge"&gt; Enlarge Text&lt;/button&gt; 123456// ...methods:&#123; enlarge()&#123; this.$emit('enlarge-text'); &#125;&#125; 有了这个 v-on:enlarge-text=&quot;postFontSize += 0.1&quot; 监听器，父级组件就会接收该事件并更新 postFontSize 的值。 使用事件抛出一个值(Emitting a Value with an Event) 有时，用一个事件来抛出一个特定的值是非常有用的。 例如我们可能想让 &lt;blog-post&gt; 组件决定它的文本要放大多少。这时可以用 $emit 的第二个参数来提供这个值： 123&lt;button v-on:click="$emit('enlarge-text', 0.1)"&gt; Enlarge Text&lt;/button&gt; 然后当在父级组件监听这个事件的时候，我们可以通过 $event 访问到被抛出的这个值(We can access the emitted event’s value with $event ) 1234&lt;blog-post ... v-on:enlarge-text="postFontSize += $event"&gt;&lt;/blog-post&gt; 或者，如果这个事件处理函数是一个方法(if the event handler is a method): 1234&lt;blog-post ... v-on:enlarge-text="onEnlargeText"&gt;&lt;/blog-post&gt; 123456// 那么这个值 将会作为第一个参数传入这个方法：methods:&#123; onEnlargeText: function(enlargeAmount)&#123; this.postFontSize += enlargeAmount &#125;&#125; 在组件上使用v-model(Using v-model on Components) 自定义事件也可以用于创建支持 v-model 的自定义输入组件(custom inputs)。记住 1&lt;input v-model="searchText"&gt; 等价于： 123&lt;input v-bind:value="searchText" v-on:input="searchText = $event.target.value"&gt; 当用在组件上，v-model 则会这样： 1234&lt;custom-input v-bind:value="searchText" v-on:input="searchText = $event"&gt;&lt;/custom-input&gt; 为了让它正常工作，这个组件内的 &lt;input&gt; 必须： 12* 将其 value 特性绑定到一个名叫 value 的prop上* 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 写成代码之后是这样的： 123456789Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value="value" v-on:input="$emit('input', $event.target.value)" &gt; `&#125;) 现在， v-model 就应该可以在这个组件上完美的工作起来了： 1&lt;custom-input v-model="searchText"&gt;&lt;/custom-input&gt; 到目前为止，关于组件自定义事件你需要了解的大概就这些了， 如果你阅读完本页内容并掌握了它的内容，我们会推荐你再回来把自定义事件读完 通过插槽分发内容(Content Distribution with Slots) 和HTML元素一样，我们经常需要一个组件传递内容(It’s often useful to be able to pass content to a component)，像这样： 123&lt;alert-box&gt; Something bad happened.&lt;/alert-box&gt; 幸好，Vue自定义的 元素让这变得非常简单： 12345678Vue.component('alert-box', &#123; template: ` &lt;div class="demo-alert-box"&gt; &lt;strong&gt;Error!&lt;/strong&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt; `&#125;) 我们只要在需要的地方加入插槽就行了——就是这么简单！ 动态组件(Dynamic Components) 有的时候，在不同组件之间进行动态切换是非常有用的，比如在一个多标签的界面里： 上述内容可以通过 Vue 的 &lt;component&gt; 元素加一个特殊的 is 特性来实现： 12&lt;!-- 组件会在 `currentTabComponent` 改变时改变 --&gt;&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt; 在上述示例中，currentTabComponent 可以包括 已注册组件的名字，或 一个组件的选项对象 你可以在这里查阅并体验完整的代码，或在这个版本了解绑定组件选项对象，而不是已注册组件名的示例。 解析DOM模板时的注意事项 有些 HTML 元素，诸如 &lt;ul&gt;、&lt;ol&gt;、&lt;table&gt; 和 &lt;select&gt;，对于哪些元素可以出现在其内部是有严格限制的。而有些元素，诸如 &lt;li&gt;、&lt;tr&gt;和 &lt;option&gt;，只能出现在其它某些特定的元素内部。 这会导致我们使用这些有约束条件的元素时遇到一些问题。例如： 123&lt;table&gt; &lt;blog-post-row&gt;&lt;/blog-post-row&gt;&lt;/table&gt; 这个自定义组件 &lt;blog-post-row&gt; 会被作为无效的内容提升到外部，并导致最终渲染结果出错。幸好这个特殊的 is 特性给了我们一个变通的办法： 123&lt;table&gt; &lt;tr is=&quot;blog-post-row&quot;&gt;&lt;/tr&gt;&lt;/table&gt; 需要注意的是如果我们从以下来源使用模板的话，这条限制是不存在的： 字符串 (例如：template: &#39;...&#39;) 单文件组件 (.vue) &lt;script type=&quot;text/x-template&quot;&gt; 到这里，你需要了解的解析 DOM 模板时的注意事项——实际上也是 Vue 的全部必要内容，大概就是这些了。 恭喜你！接下来还有很多东西要去学习，不过首先，我们推荐你先休息一下，试用一下 Vue，自己随意做些好玩的东西。 如果你感觉已经掌握了这些知识，我们推荐你再回来把完整的组件指南，包括侧边栏中组件深入章节的所有页面读完。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与算法]]></title>
    <url>%2F2019%2F04%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[动态规划实现斐波拉契数列]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[表单输入绑定(Form Input Bindings)]]></title>
    <url>%2F2019%2F04%2F05%2F%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[基础用法(Basic Usage) 你可以用 v-model 指令在表单 &lt;input 、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。 它会根据控件类型自动选取正确的方法来更新元素。 尽管有些神奇，但 v-model 本质上不过是语法糖。 它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value 、checked 、selected 特性(attributes)的初始值，而总是将Vue实例的数据作为数据来源。你应该 通过JavaScript在组件的 data 选项中声明初始值 v-model 为不同的输入元素，在内部使用不同的属性(properties)，并抛出不同的事件： 123* text 和 textarea 元素使用 value 属性 和 input 事件* checkbox 和 radio 使用 checked 属性 和 change 事件* select 字段将 value 作为 prop 并将 change 作为 事件 123对于需要使用 输入法 （如中文、日文、韩文等）的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件 文本(Text)1234&lt;input v-model="message" placeholder="edit me"&gt;&lt;p&gt; Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本(Mult-iline text)123456&lt;span&gt;Multiline message is: &lt;/span&gt;&lt;p style="white-space: pre-line;"&gt; &#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model="message" placeholder="add multiple lines"&gt;&lt;/textarea&gt; Note: 在文本区域(textarea)插值 (&lt;textarea&gt; &lt;/textarea&gt;) 并不会生效，应该用 v-model 来代替。 复选框(Checkbox) 单个复选框，绑定到布尔值： 12345&lt;!-- 这里的v-model绑定到了 checked 属性 --&gt;&lt;input type="checkbox" id="checkbox" v-model="checked"&gt;&lt;!-- for属性规定label与哪个指定id的表单元素绑定 --&gt;&lt;label for="checkbox"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 123456new Vue(&#123; // ... data: &#123; checked: false &#125;&#125;) 多个复选框，绑定到同一个数组： 12345678910111213&lt;div id="example-3"&gt; &lt;input type="checkbox" id="jack" value="Jack" v-model="checkedName"&gt; &lt;label for="jack"&gt;Jack&lt;/label&gt; &lt;input type="checkbox" id="john" value="John" v-model="checkedName"&gt; &lt;label for="john"&gt;John&lt;/label&gt; &lt;input type="checkbox" id="mike" value="Mike" v-model="checkedName"&gt; &lt;label for="mike"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选按钮(Radio)1234567891011&lt;div id="example-4"&gt; &lt;input type="radio" id="one" value="One" v-model="picked"&gt; &lt;label for="one"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type="radio" id="two" value="Two" v-model="picked"&gt; &lt;label for="two"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;) 选择框(Select) 单选时： 123456789&lt;div id="example-5"&gt; &lt;select v-model="selected"&gt; &lt;option disabled value=""&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '...', data: &#123; selected: '' &#125;&#125;) 12345如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt;元素将被渲染为 “未选中”状态。在IOS中，这会使 用户无法选择第一个选项。因为这样的情况下，IOS不会触发change事件因此，更推荐像上面这样提供一个值为空的禁用选项。 多选时（绑定到一个数组） 123456789&lt;div id="example-6"&gt; &lt;select v-model='selected' multiple style="width: 50px;"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;) 用 v-for 渲染的动态选项： 12345&lt;select v-model="selected"&gt; &lt;option v-for="option in options" v-bind:value="option.value"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected:&#123;&#123; selected &#125;&#125;&lt;/span&gt; 1234567891011new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;) 值绑定(Value Bindlings) 对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串（对于复选框也可以是布尔值）： 12345678910&lt;!-- 当选中时，picked 为字符串 "a" --&gt;&lt;input type="radio" v-model="picked" value='a'&gt;&lt;!-- toggle 为 true 或 false --&gt;&lt;input type="checkbox" v-model='toggle'&gt;&lt;!-- 当选中第一个选项时，selected 为字符串“abc" --&gt;&lt;select v-model="selected"&gt; &lt;option value="abc"&gt;ABC&lt;/option&gt;&lt;/select&gt; 但是，有时我们可能想把值绑定到Vue实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。 复选框(Checkbox)123456&lt;input type="checkbox" v-model="toggle" true-value="yes" false-value="no" &gt; 12345// 当选中时vm.toggle === 'yes'// 当没有选中时vm.toggle === 'no' 123这里的 true-value 和 false-value 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。 单选按钮(Radio)1&lt;input type="radio" v-model="pick" v-bind:value="a"&gt; 12// 选中时vm.pick === vm.a 选项框的选项(Select Options)1234&lt;select v-model="select"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value="&#123; number: 123 &#125;"&gt;123&lt;/option&gt;&lt;/select&gt; 123// 当选中时typeof vm.selected // =&gt; objectvm.selected.number // =&gt; 123 修饰符(Modifiers).lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步(除了上述输入法组合文字时)。 你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步： 12&lt;!-- 在 change 时而非 input 时更新 --&gt;&lt;input v-model.lazy="msg"&gt; .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： 1&lt;input v-model.number="age" type="number"&gt; 这通常很有用，因为即使在 type=&quot;number&quot; 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： 1&lt;input v-model.trim=&quot;msg&quot;&gt; 在组件上使用v-model 如果你还不熟悉 Vue 的组件，可以暂且跳过这里。 HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 v-model 一起使用！要了解更多，请参阅组件指南中的自定义输入组件。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试知识]]></title>
    <url>%2F2019%2F04%2F05%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1234本文完全采纳微信公众号：JavaScript 提供的优秀文章，读来让人受益匪浅，特此说明。并向您强烈推荐关注此公众号，学习JavaScript。原作者：appleguardu原文链接：https://segmentfault.com/a/1190000018603454 基本功考察关于HTML html 语义化标签的理解、结构化的理解；能否写出简洁的html结构；SEO优化。 h5中新增的属性，如自定义属性data、类名className等；新增表单元素；拖拽Drag。 h5中新增的API、修改的API、废弃的API稍作了解(离线存储、audio、video)。 关于CSS CSS选择器(三大特性) BFC机制 盒模型 CSS模块化开发(封装)；SCSS 和 LESS的使用 屏幕适配以及页面自适应 CSS3中新增的选择器 CSS3中新增的属性，transform、trasition、animation等 关于布局 标准文档流(padding + margin + 负margin) + 浮动 float + 定位 left + right + top + bottom 百分比布局：px单位用 %num 代替，占父级元素的百分比 flex弹性布局：主轴、辅助轴的几个属性 grid栅格布局：使用框架中的类名来替代，本质上还是百分比布局 关于JS基础 变量数据类型及检测：基本 + 引用 运算符：算术 + 条件 + 逻辑 + 位 + 短路、隐式转换等 条件、循环、异常处理、if、switch(){case: xxx}、try、catch、finally、throw 函数定义、调用方式(apply、call、直接调用)；传参：实参 给 形参赋值 字符串、数组、对象常用API 正则表达式 关于JS高级 作用域、作用域链、闭包 原型、原型链、继承 函数上下文、this指向 js运行机制、事件队列和循环 Ajax原理、axio库 同步、异步编程 jQuery源码学习 关于浏览器 浏览器的构成和运行机制 浏览器的内核 浏览器交互：BOM和DOM相关webApi、监听事件 浏览器缓存机制 浏览器渲染原理 浏览器的安全性：跨域和攻击 关于网络协议 HTTP协议 cookie、session、token 关于ES6语法 字符串、数组、对象拓展的Api 变量拓展：let、const结构赋值、块级作用域 函数拓展：箭头函数默认参数、rest参数 展开运算符、模板字符串 set和map数据结构 迭代器和生成器函数next和yield的理解 proxy对象属性迭代器：属性的读取(get)和设置(set)相关操作 promise对象、异步编程的解决方案 async + await：异步编程的终极方案 promise + generator 的语法糖 class 语法、构造函数的语法糖 模块化编程export + import 的导出和导入 Vue基础 基本指令 实例的属性和方法 实例的生命周期 组件基础：创建、注册、添加属性方法、套用等 组件通信传值，父子、兄弟、跨级 插槽slot等 Vue高级 vue-router：搭建SPA 12345* 路由、组件的配置* 路由间的传值* 路由跳转* 路由的导航守卫* 记住在router.js和组件页面中的使用方式 vuex：状态管理、数据仓库store 1234* 实例化仓库的5大属性的使用* state、getters、mutations、actions、modules* 辅助函数mapState等，仓库中计算属性的映射、方便操作* 记住在store.js和组件中使用方式 Vue深入、源码阅读 数据响应式原理 virtual dom diff 算法 nextTick等 项目能力考察项目能力 vue-cli脚手架搭建和功能配置 vue.config.js webpack 的常用配置 项目构建打包 熟悉各类框架文档 UI框架：Bootstrap、MUI、Element-UI等 常用的插件整理：整理一个自己插件库，封装自己的方法库、组件等 常用工具熟练度 PC端和移动端开发注意事项 经验总结：快速确定项目的技术选型 坑点总结：项目遇到坑坑坑 项目中的性能优化记录（都是细节点，多记录） 需求文档的理解，可以结合项目流程图、UML图 记录习惯养成。 问题解决能力：bug定位调试、查找文档、寻求他人 模块化、组件化开发能力 项目分类；各类文件整理、分类 各类功能封装 组件和功能模块的抽离、解耦、复用 内功考察面向对象的编程思想 类的抽象 对象的封装、继承 为了更好的去管理数据、分类数据，实现高内聚、低耦合 设计模式设计模式 感觉也是面向对象思想再度抽象成现实中某些特定模式 数据结构与算法 学习常用的排序搜索算法、顺序表、链表、栈、队列、树、堆等 考验你的抽象思维和数学功底 将现实需求抽象成计算机代码的思维能力 附加技能考察学习能力 持续学习的态度——博客、笔记记录 技术论坛活跃度高、问答多 Github开源项目参与 了解一门后端语言 Java、Python、node.js 数据库 mysql、redis、mongodb node + express搭建本地服务 系统编程 Linux命令行编程、系统文件管理 多任务、多线程、多进程、协程、并发、并行、串行、同步、异步等概念的理解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点清单</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Router入门]]></title>
    <url>%2F2019%2F04%2F03%2FVue-Router%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[安装NPM1npm install vue-router 如果在一个模块化工程中使用它，必须要通过Vue.use()明确地安装路由功能： 1234import Vue from 'vue'import VueRouter from 'vue-router'Vue.use(VueRouter) 如果使用全局的script标签，则无须如此（手动安装） 构建开发版(Dev Build) 如果你想最新的开发版，就得从GitHub上直接 clone，然后自己build一个 vue-router 。 1234git clone https://github.com/vuejs/vue-router.git node_modules/vue-routercd node_modules/vue-routernpm installnpm run build 介绍 Vue Router 是 Vue.js 官方的路由管理器(Vue Router is the offical router for Vue.js) 它和Vue.js的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有： 12345678* 嵌套的路由/视图表(Nested route/view mapping)* 模块化的、基于组件的路由配置(Modular, component-based router configuration)* 路由参数、查询、通配符(Route params, query, wildcards)* 基于Vue.js过渡系统的视图过渡效果(View transition effects powered by Vue.js' transition system)* 细粒度的导航控制(Fine-grained navigation control)* 带有自动激活的CSS class的链接(Links with automatic active CSS classes)* HTML5历史模式或hash模式，在IE9中自动降级(HTML5 history mode or hash mode, with auto-fallback in IE9)* 自定义的滚动条行为(Customizable Scroll Behavior) 现在开始起步或尝试一下我们的示例吧 (查看仓库的 README.md 来运行它们)。 基础起步(Getting Started) 教程中的案例代码将使用 ES2015 来编写。 同时，所有的例子都将使用完整版的 Vue 以解析模板。更多细节请移步这里。 用 Vue.js + Vue Router 创建单页应用，是非常简单的。 使用 Vue.js，我们已经可以通过组合组件来组成应用程序(We are already composing our application with components)， 当你要把Vue Router 添加进来，我们需要做的是，将组件(components)映射到路由(routes) 然后告诉 Vue Router 在哪里渲染它们。 123456789&lt;script src="https://unpkg.com/vue/dist/vue.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/vue-router/dist/vue-router.js"&gt;&lt;/script&gt;&lt;div id="app"&gt; &lt;h1&gt;Hello App&lt;/h1&gt; &lt;p&gt; &lt;!-- 使用 router-link 组件 来导航 --&gt; &lt;/p&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132// 0. 如果使用模块化机制编程，导入Vue和VueRouter，要调用 Vue.use(VueRouter)// 1.定义（路由route）组件// 组件可以从其他文件 import 进来// 也可以像下面这样简单定义const Foo = &#123; template: '&lt;div&gt;foo&lt;/div&gt;'&#125;const Bar = &#123; template: '&lt;div&gt;bar&lt;/div&gt;'&#125;// 2.定义路由// 每个路由应该映射一个组件// 其中component可以是 通过Vue.extend() 创建的组件构造器// 或者，只是一个组件的配置对象// 我们晚点再讨论嵌套路由const routes = [ &#123; path: '/foo', component: Foo &#125;, &#123; path: '/bar', component: Bar&#125;]// 3.创建 router 实例，// 然后传 routes 配置参数// 你可以传别的配置参数const router = new VueRouter(&#123; routes // 相当于 routes: routes&#125;)// 4.创建和挂载根实例// 记得要通过 router 配置参数注入路由const app = new Vue(&#123; router&#125;).$mount('#app')// 现在，应用已经启动了 通过注入路由器(By injecting the router)，我们可以在任何组件内通过 this.$router 访问路由器 也可以通过 this.$route 访问当前路由(the current route) 12345678910111213141516// Home.vueexport default&#123; computed: &#123; username()&#123; // 我们很快就会看到 params 是什么 return this.$route.params.username &#125; &#125;, methods:&#123; goBack()&#123; window.history.length &gt; 1 ? this.$router.go(-1) : this.$router.push('/') &#125; &#125;&#125; 该文档通篇都常使用 router 实例。留意一下 this.$router 和 router 使用起来完全一样。 我们使用 this.$router 的原因是我们并不想在每个独立需要封装路由的组件中都导入路由。 要注意，当 &lt;router-link&gt; 对应的路由匹配成功，将自动设置class属性值 .router-link-active。查看API文档学习更多文档 动态路由匹配(Dynamic Route Matching) 我们经常需要把 某种模式 匹配到的所有路由，全部 映射到 同一个组件。 例如，我们有一个User组件，对于所有ID各不相同的用户，都要使用这个组件来渲染。 那么我们可以在 vue-router 的路由路径中使用 “动态路由参数(dynamic segment)”来达到这个效果： 123456789const User = &#123; template: '&lt;div&gt;User&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ // 动态路径参数，以冒号开头 &#123; path: '/user/:id', component: User &#125; ]&#125;) 现在呢，像 /user/foo 和 /user/bar 都将映射到相同的路由(Now URLs like /user/foo and /user/bar will both map to the same route) 一个“路由参数(dynamic segment)”使用冒号 : 标记。 当匹配到一个路由时(When a route is matched, the value of the dynamic segments will be exposed as this.$route.params)，参数值会被设置到 this.$route.params，可以在每个组件内使用。 于是，我们可以更新 User 模板，输出当前用户的ID： 123const User = &#123; template: '&lt;div&gt; User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125; 你可以在一个路由中 设置多段“路由参数” ，对应的值都会设置到 $route.params 中。 模式 匹配路径 $route.params /user/:username /user/evan { username: ‘evan’ } /user/:username/post/:post_id /user/evan/post/123 {username: ‘evan’, post_id: ‘123’} 除了 $route.params 外， $route 对象还提供了其它有用的信息。例如，$route.query (如果URL中有查询参数)、$route.hash 等等。 响应路由参数的变化(Reacting to Params Changes) 提醒一下，当使用路由参数时，例如从 /user/foo 导航到 /user/bar , 原来的组件实例会被复用。因为两个路由都渲染同一个组件，比起销毁再创建，复用则显得更加高效。 不过，这也意味着组件的生命周期钩子不会再被调用 *** 复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch(监测变化) $route 对象： 12345678const User = &#123; template: '...', watch: &#123; '$route'( to, from )&#123; // 对路由变化作出响应。。。 &#125; &#125;&#125; 或者使用2.2中引入的 beforeRouteUpdate 导航守卫： 1234567const User = &#123; template: '...', beforeRouteUpdate(to, from, next)&#123; // react to route changes... // don't forget to call next() &#125;&#125; 捕获所有路由 或 404 Not found 路由(Catch all / 404 Not found Route) 常规参数只会 匹配被 / 分隔的URL片段中的字符。如果想匹配 任意路径，我们可以使用通配符 * : 12345678&#123; // 会匹配所有路径 path: '*'&#125;&#123; // 会匹配以 user- 开头的任意路径 path: '/user-*'&#125; 当使用 通配符 路由时，请确保路由的顺序是正确的，也就是说含有 通配符 的路由应该放在最后。 路由 { path: &#39;*&#39;} 通常用于客户端404错误。 如果你使用了 History模式，请确保正确配置你的服务器。 当使用一个 通配符 时，$route.params 内会自动添加一个名为 pathMatch 参数。它包含了URL通过 通配符 被匹配的部分： 1234567// 给出一个路由 &#123; path: '/user-*' &#125;this.$router.push('/user-admin')this.$route.params.pathMatch // 'admin'// 给出一个路由 &#123; path: '*' &#125;this.$router.push('/non-existing')this.$route.params.pathMatch // '/non-existing' 高级匹配模式(Advanced Matching Patterns) vue-router 使用 path-to-regexp 作为路径匹配引擎，所以支持很多高级的匹配模式 例如：可选的动态路径参数、匹配零个或多个、一个或多个，甚至是自定义正则匹配。 查看它的 文档 学习高阶路径匹配，还有 这个例子 展示 vue-router 怎么使用这类匹配。 匹配优先级(Matching Priority) 有时候，同一个路径可以匹配多个路由，此时，匹配的优先级就按照路由的定义顺序： 谁先定义，谁的优先级就高。 嵌套路由(Nested Routes) 实际生活中的应用界面，通常由多层嵌套的组件组合而成。同样地，URL中各段动态路径也 按某种结构 对应 嵌套的各层组件，例如： 12345678/user/foo/profile /user/foo/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ 借助 vue-router，使用嵌套路由配置，就可以很简单地表达这种关系。 1234&lt;!-- 接着上节创建的app --&gt;&lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 123456789const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes:[ &#123; path: '/user/:id', component: User &#125; ]&#125;) 这里的 &lt;router-view&gt; 是最顶层的出口，渲染 最高级路由 匹配到的组件。 同样地，一个被渲染组件同样可以包含自己的嵌套 &lt;router-view&gt; 。 例如，在 User 组件的模板添加一个 &lt;router-view&gt; : 12345678const User = &#123; template: ` &lt;div class="user"&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `&#125; 要在嵌套的出口中渲染组件，需要在 VueRouter 的参数中使用 children 配置： 1234567891011121314151617181920const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功， // UserProfile 会被渲染在 User 的 &lt;router-view&gt;中 path: 'profile', component: UserProfile &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 会被渲染在 User 的 &lt;router-view&gt; 中 path: 'posts', component: UserPosts &#125; ] &#125; ]&#125;) 注意，以 / 开头的嵌套路径，会被当做根路径。这会让你充分地使用嵌套组件而无须设置嵌套路径 你会发现， children 配置就是像 routes 配置一样的路由配置数组，所以呢，你可以嵌套多层路由。 此时，基于上面的配置，当你访问 /user/foo 时，User 的出口是不会渲染任何东西，这是因为没有匹配到合适的路由。如果你想渲染点什么，可以提供一个空的子路由： 123456789101112131415const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, children: [ // 当 /user/:id 匹配成功 // UserHome会被渲染在User的&lt;router-view&gt;中 &#123; path: '', component: UserHome &#125; // ...其他子路由 ] &#125; ]&#125;) 编程式的导航(Programmatic Navigation) 除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助router的实例方法，通过编写代码来实现： 1router.push(location, onComplete?, onAbort?) 注意：在 Vue 实例内部，你可以通过 $router 访问路由实例(the router instance)。因此你可以调用 this.$router.push 想要导航到 不同的 URL，则使用 router.push 方法。 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的URL 当你点击 &lt;router-link&gt; 时，这个方法会在内部调用，所以说，点击 &lt;router-link :to=&quot;...&quot;&gt; 等同于调用 router.push(...) 声明式 编程式 &lt;router-link :to=&quot;...&quot;&gt; router.push(...) 该方法的参数可以是一个字符串路径，或者是一个描述地址的对象。例如： 1234567891011// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: '123' &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;) 注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是，下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path： 12345const userId = '123'router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path; `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; user 同样的规则也使用于 router-link 组件的 to 属性 在 2.2.0+，可选的在 router.push 或 router.replace 中提供 onComplete 和 onAbort 回调作为第二个和第三个参数。这些回调将会在导航成功完成 (在所有的异步钩子被解析之后) 或终止 (导航到相同的路由、或在当前导航完成之前导航到另一个不同的路由) 的时候进行相应的调用。 注意： 如果目的地和当前路由相同，只有参数发生了改变 (比如从一个用户资料到另一个 /users/1 -&gt; /users/2)，你需要使用 beforeRouteUpdate 来响应这个变化 (比如抓取用户信息) 1router.replace(location, onComplete?, onAbort?) 跟 router.push 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。 声明式 编程式 &lt;router-link :to=&quot;...&quot; replace&gt; router.replace(...) 1router.go(n) 这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 window.history.go(n)。 123456789101112// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 操作 History 你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的。 因此，如果你已经熟悉 Browser History APIs，那么在 Vue Router 中操作 history 就是超级简单的。 还有值得提及的，Vue Router 的导航方法 (push、 replace、 go) 在各类路由模式 (history、 hash 和 abstract) 下表现一致。 命名路由(Named Routes) 有时候，通过一个名称来标识一个路由显得更方便一些 特别是在链接一个路由，或者是执行一些跳转时。 你可以在创建Router实例的时候，在 routes 配置中给某个路由设置名称。 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;) 要链接到一个命名路由，可以给 &lt;router-link&gt; 的 to 属性传一个对象： 1&lt;router-link :to="&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;"&gt;User&lt;/router-link&gt; 这跟代码调用 router.push() 是一回事： 1router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;) 这两种方式都会把路由导航到 /user/123 路径。 例子 命名视图(Named Views) 有时想同时(同级)展示多个视图，而不是嵌套展示(Sometimes you need to display multiple views at the same time instead of nesting them) 例如，创建一个布局，有 sidebar(侧导航) 和 main(主内容)两个视图，这个时候 命名视图就派上用场了。 你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 &lt;router-view&gt; 没有设置名字，那么默认为 default 123&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染(A view is rendered by using a component)，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置（带上 s）： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: '/', components: &#123; default: Foo, a: Bar, b: Baz &#125; &#125; ]&#125;) 以上案例相关的可运行代码请移步 这里 嵌套命名视图(Nested Named Views) 我们也有可能使用 命名视图 创建嵌套视图的复杂布局。 这时你也需要命名 用到的嵌套 router-view 组件。我们以一个设置面板为例： 123456789/settings/emails /settings/profile+-----------------------------------+ +------------------------------+| UserSettings | | UserSettings || +-----+-------------------------+ | | +-----+--------------------+ || | Nav | UserEmailsSubscriptions | | +------------&gt; | | Nav | UserProfile | || | +-------------------------+ | | | +--------------------+ || | | | | | | | UserProfilePreview | || +-----+-------------------------+ | | +-----+--------------------+ |+-----------------------------------+ +------------------------------+ Nav 只是一个常规组件(a regular component) UserSettings 是一个视图组件(the view component) UserEmailsSubscriptions 、UserProfile 、UserProfilePreview 是嵌套的视图组件(nested view component) 注意：我们先忘记HTML/CSS具体的布局样子，只专注在用到的组件上 UserSettings 组件的 &lt;template&gt; 部分应该是类似下面的这段代码： 12345678910&lt;!-- UserSettings.vue --&gt;&lt;div&gt; &lt;h1&gt; User Settings &lt;/h1&gt; &lt;NavBar/&gt; &lt;router-view/&gt; &lt;router-view name="helper"/&gt;&lt;/div&gt; 嵌套的视图组件 在此已经被忽略了，但是你可以在这里找到完整的源代码 然后你就可以用这个路由配置完成该布局： 123456789101112131415161718&#123; path: '/settings'， // 你也可以在顶级路由 就配置命名视图 component: UserSettings, children: [ &#123; path: 'emails', component: UserEmailsSubscriptions &#125;, &#123; path: 'profile', components: &#123; default: UserProfile, helper: UserProfilePreview &#125; &#125; ]&#125; 一个工作示例在这里 重定向和别名(Redirect and Alias)重定向(Redirect) 重定向也是通过 routes 配置来完成，下面例子是从 /a 重定向到 /b ： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: '/b'&#125; ]&#125;) 重定向的目标也可以是一个命名的路由： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: &#123; name: 'foo'&#125;&#125; ]&#125;) 甚至是一个方法，动态返回重定向目标： 12345678910const router = new VueRouter(&#123; routes: [ &#123; path: '/a', redirect: to =&gt; &#123; // 方法接收 目标路由 作为参数 // return 重定向的 字符串路径/路径对象 &#125; &#125; ]&#125;) 注意 导航守卫 并没有应用在跳转路由上，而仅仅应用在其目标上。 下面这个例子中，为 /a 路由添加一个 beforeEach 或 beforeLeave 守卫并不会有任何效果。 其他高级用法，请参考例子 别名(Alias) 重定向的意思是，当用户访问 /a 时，URL将会被替换成 /b，然后匹配路由 为 /b，那么别名又是什么呢？ /a 的别名是/b，这意味着，当用户访问 /b 时，URL会保持为 /b，但是路由匹配为 /a，就像用户访问 /a 一样 上面对应的路由配置为： 12345const router = new VueRouter(&#123; routes: [ &#123; path: '/a', component: A, alias: '/b' &#125; ]&#125;) “别名”的功能让你可以自由地将UI结构映射到任意的URL，而不是受限于配置的嵌套路由结构。 路由组件传参(Passing Props to Route Components) 在组件中使用 $route 会使之与其对应的路由形成高度耦合，从而使组件只能在某些特定的URL上使用，限制了其灵活性 使用 props 将组件和路由解耦： 取代与 $route 的耦合 123456789const User = &#123; template: '&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path：'/user/:id', component: User &#125; ]&#125;) 通过 props 解耦 123456789101112131415161718192021const User = &#123; props: ['id'], template: '&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;'&#125;const router = new VueRouter(&#123; routes: [ &#123; path: '/user/:id', component: User, props: true &#125;, // 对于包含命名视图的路由， 必须分别为每个命名视图添加 props 选项 &#123; path: '/user/:id', components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125; ]&#125;) 这样你便可以在任何地方使用该组件，使得该组件更易于重用和测试。 布尔模式(Boolean mode) 如果 props 被设置为 true，route.params 将会被设置为组件属性(will be set as the component props) 对象模式(Object mode) 如果 props 是一个对象，它会被按原样设置为 组件属性。 当 props 是静态的时候有用 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/promotion/from-newsletter', component: Promotion, props: &#123; newsletterPopup: false &#125; &#125; ]&#125;) 函数模式(Function mode) 你可以创建一个函数返回props（You can create a function that returns props) 这样你便可以将参数转换成另一种类型，将静态值与基于路由的值结合等等 123456789const router = new VueRouter(&#123; routes: [ &#123; path: '/search', component: SearchUser, props: (route) =&gt; (&#123; query: route.query.q &#125;) &#125; ]&#125;) URL /search?q=vue 会将 {query: &#39;vue&#39;} 作为属性传递给 SearchUser 组件。 请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。 如果你需要状态来定义 props，请使用包装组件，这样 Vue 才可以对状态变化做出反应。 HTML5 History模式 前端路由最常用的两种模式——hash模式 和 history模式。Vue-Router 也用这两种模式 Hash模式的原理是 onhashchange 事件，可以在 window 对象上监听这个事件 1234567891011121314151617181920window.onhashchange = function(event)&#123; console.log(event.oldURL, event.newURL); let hash = location.hash.slice(1); document.body.style.color = hash;// # 后面的值&#125;// 本代码可以 通过改变 hash 来改变页面字体颜色，一定程度上说明了原理// 我们在url后面随便添加一个#xx触发这个事件// 比如当你在 URL：https://blog.csdn.net/lla520/article/details/77894985 // 后面加上 #good// https://blog.csdn.net/lla520/article/details/77894985#good// 以及加上 #yellow/vv=list// https://blog.csdn.net/lla520/article/details/77894985#yellow/vv=list/**不断变化的 hash 使得 URL 也在不断变化，这些变化的URL会被浏览器记录下来，在点击浏览器的前进后退按钮时，页面颜色会随之改变。而且hash 值变化不会导致浏览器向服务器发出请求。这样一来，尽管浏览器没有向服务器发送请求，但是页面状态和URL关联起来了。百度云盘就采用了 hash 路由，看起来就是这个样子：https://pan.baidu.com/disk/home#list/vmode=list*/ 随着 History API 的到来，前端路由 开始进化了，Hash模式只能改变#后面的url片段，而History模式则给了前端完全的自由 History API可分为两大部分：切换 和 修改历史状态 切换 历史状态包括 back, forward, go 三个方法 12345678/**(谷歌)浏览器在前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转(也许叫跳更合适)*/history.go(-2) // 后退两次history.go(2) // 前进两次history.back() // 后退history.forward() // 前进 修改 历史状态包括 pushState, replaceState 两个方法，这两个方法接收三个参数：stateObject, title[, url] history.pushState(stateObject, title[, url])往历史记录堆栈顶部添加一条记录；stateObject 会在onpopstate事件触发时作为参数传递过去；title为页面标题，当前所有浏览器都会 忽略此参数；url为页面地址，可选，缺省为当前页地址； 在hash模式下，前端路由修改的是#中的信息，而浏览器请求时是不带它玩的，所以没有问题。 但是在history下，你可以自由的修改path，当刷新时，如果服务器中没有相应的响应或者资源，会分分钟刷出一个404来。 vue-router 默认为 hash 模式 ——使用URL的hash来模拟一个完整的URL，于是当URL改变时，页面不会重新加载。此时的URL就像： https://aaa/aa#bbb/listobj=red 如果不想要很丑的 hash，我们可以用路由的 history模式，这种模式充分利用 history.pushState API 来完成URL跳转而无须重新加载页面。 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 当你使用 history 模式 时，URL就像正常的url，例如http://yoursite.com/user/id，也好看 不过history模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 http://oursite.com/user/id 就会返回 404，这就不好看了。 所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果URL匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你app依赖的页面。 后端配置例子(Example Server Configurations) Apache 12345678&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; 除了 mod_rewrite，你也可以使用 FallbackResource。 nginx 123location / &#123; try_files $uri $uri/ /index.html;&#125; 原生Node.js(Native Node.js) 123456789101112131415161718const http = require('http')const fs = require('fs')const httpPort = 80http.createServer((req, res) =&gt; &#123; fs.readFile('index.html', 'utf-8', (err, content) =&gt; &#123; if(err)&#123; console.log('We cannot open index.html file.') &#125; res.writeHead(200, &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;) res.end(content) &#125;)&#125;).listen(httpPort, () =&gt; &#123; console.log('Server listening on: http://localhost:%s', httpPort)&#125;) 基于Node.js的Express 对于 Node.js/Express，请考虑使用 connect-history-api-fallback 中间件。 Internet Information Services(IIS) 警告 给个警告，因为这么做以后，你的服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。 为了避免这种情况，你应该在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。 123456const router = new VueRouter(&#123; mode: 'history', routes: [ &#123; path: '*', component: NotFoundComponent &#125; ]&#125;) 或者，如果你使用 Node.js 服务器，你可以用服务端路由匹配到来的 URL，并在没有匹配到路由的时候返回 404，以实现回退。更多详情请查阅 Vue 服务端渲染文档。 进阶导航守卫(Navigation Guards)1“导航”表示路由正在发生变化 正如其名，vue-router 提供的导航守卫主要 用来通过跳转或取消的方式(redirecting it or canceling it) 守卫导航。 有很多 植入路由导航过程 的机会：全局的(globally)，单个路由独享的(per-route)，或者组件级别的(in-component)。 请记住 参数或查询的改变并不会触发进入/离开的导航守卫，(Remember that params or query changes won’t trigger enter/leave navigation guards)，你可以通过观察(watch) $route 对象来对应这些变化，或使用 beforeRouteUpdate 的组件内守卫(in-component guard) 全局前置守卫(Global Before Guards) 你可以使用 router.beforeEach 注册一个全局前置守卫： 1234567const router = new VueRouter(&#123; ...&#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 当一个导航触发时，全局前置守卫按照创建顺序调用。守卫是异步解析执行，此时导航在所有守卫resolve完之前 一直处于等待中。 每个守卫方法接收三个参数(Every guard function receives three arguments)： to: Route ：即将要进入的目标——路由对象(the target Route Object being navigated to) from: Route ：当前导航正要离开的路由 next: Function : 一定要调用该方法来 resolve 这个钩子。执行效果依赖 next 方法的调用参数： 123456789101112131415* next() // 进行管道中的下一个钩子(move on to the next hook in the pipeline),// 如果全部钩子执行完了，则导航的状态就是 confirmed(确认的)* next(false) // 中断当前导航。// 如果浏览器的URL改变了(可能是用户手动或者浏览器后退按钮)，// 那么URL地址会重置到 from 路由对应的地址。* next(&apos;/&apos;) 或者 next(&#123; path: &apos;/&apos; &#125;) // 跳转到一个不同的地址// 当前的导航被中断，然后进行一个新的导航// 你可以向next传递任意位置对象(location object),// 且允许设置诸如 replace: true、name: &apos;home&apos;之类的选项，// 以及任何用在 router-link 的to prop 或 router.push 中的选项* next(error)[V2.4.0+]// 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 请确保要调用 next 方法，否则钩子就不会被 resolved 全局解析守卫(Global Resolve Guards)[V 2.5.0 新增] 可以用router.beforeResolve 注册一个全局守卫，这和router.beforeEach 类似，区别就是在 导航被确认 之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用。 全局后置钩子(Global After Hooks) 你可以注册全局后置钩子(You can also register global after hooks)，然而和守卫不同的是，这些钩子不会接受next函数也不会改变导航本身(however unlike guards, these hooks do not get a next function and cannot affect the navigation)： 123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 路由独享的守卫(Per-Route Guard) 你可以在路由配置(route’s configuration object)上直接定义beforeEnter 守卫(guards)： 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // ... &#125; &#125; ]&#125;) 这些守卫与全局前置守卫的方法参数是一样的(These guards have the exact same signature as global before guards) 组件内的守卫(In-Component Guards) 最后，你可以在路由组件内直接定义以下路由导航守卫： beforeRouteEnter beforeRouteUpdate [V2.2 新增] beforeRouteLeave 123456789101112131415161718192021const Foo = &#123; template: '...', beforeRouteEnter(to, from, next)&#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 this // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate(to, from, next)&#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id, // 在/foo/1 和 /foo/2 之间跳转的时候，由于会渲染同样的 Foo 组件 // 因此组件实例会被复用。而这个钩子就会在这个情况下被调用 // 可以访问组件实例 this &#125;， beforeRouteLeave(to, from, next)&#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 this &#125;&#125; beforeRouteEnter 守卫 不能 访问 this，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。 不过，你可以通过传一个回调给 next 来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。 12345beforeRouteEnter(to, from, next)&#123; next( vm =&gt; &#123; // 通过 vm 访问组件实例 &#125;)&#125; 请注意，beforeRouteEnter 是支持给 next 传递回调的唯一守卫。 对于 beforeRouteUpdate 和 beforeRouteLeave 来说，this 已经可用了，所以 不支持 传递回调，因为没有必要了。 12345beforeRouteUpdate(to, from, next)&#123; // just use this this.name = to.params.name next()&#125; 离开守卫beforeRouteLeave 通常用来禁止用户在还未保存修改前突然离开，该导航可以通过 next(false) 来取消 12345678beforeRouteLeave(to, from, next)&#123; const answer = window.confirm('Do you really want to leave, you have unsaved changes'); if(answer)&#123; next() &#125;else&#123; next(false) &#125;&#125; 完整的导航解析流程(The Full Navigation Resolution Flow) 导航被触发(Navigation triggered) 在失活的组件里调用离开守卫(Call leave guards in deactivated components) 调用全局的 beforeEach 守卫(Call global beforeEach guards) 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+) (in reused components) 在路由配置里调用 beforeEnter (Call beforeEnter in route component) 解析异步路由组件(Resolve async route components) 在被激活的组件里调用 beforeRouteEnter 调用全局的 beforeResolve 守卫 导航被确认(Navigation confirmed) 调用全局的 afterEach 钩子 触发DOM更新 用创建好的实例调用 beforeRouteEnter 守卫中传给 next 的回调函数 路由元信息(Route Meta Fields) 定义路由的时候可以配置 meta 字段(You can include a meta field when defining a route)： 12345678910111213141516const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, children:[ &#123; path: 'bar', component: Bar, // a meta field meta: &#123; requiresAuth: true &#125; &#125; ] &#125; ]&#125;) 那么如何访问这个 meta 字段呢？ 首先，我们称呼 routes 配置中的每个路由对象为 路由记录。(First, each route object in the routes configuration is called a route record) 路由记录可以是嵌套的，因此，当一个路由匹配成功后，他可能匹配多个路由记录 例如，根据上面的路由配置，/foo/bar 这个 URL 将会匹配父路由记录以及子路由记录。 一个路由匹配到的所有路由记录会暴露为 $route 对象 (还有在导航守卫中的路由对象) 的 $route.matched 数组。因此，我们需要遍历 $route.matched 来检查路由记录中的 meta字段。 下面例子展示在全局导航守卫中检查元字段： 12345678910111213141516router.beforeEach((to, from, next) =&gt; &#123; if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123; // this route requires auth, check if logged in // if not, redirect to login page. if (!auth.loggedIn()) &#123; next(&#123; path: '/login', query: &#123; redirect: to.fullPath &#125; &#125;) &#125; else &#123; next() &#125; &#125; else &#123; next() // 确保一定要调用 next() &#125;&#125;) 过渡动效(Transitions) &lt;router-view&gt; 是最基本的动态组件，所以我们可以用&lt;transition&gt; 组件给它添加一些过渡效果（we can apply transition effects to it the same way using the &lt;transition&gt;)： 123&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; Transition 的所有功能 在这里同样适用。 单个路由的过渡(Per-Route Transition) 上面的用法会给所有路由设置一样的过渡效果， 如果你想让每个路由组件有各自的过渡效果，可以在各路由组件内使用 &lt;transition&gt; 并设置不同的 name。 123456789101112131415const Foo = &#123; template: ` &lt;transition name="slide"&gt; &lt;div class="foo"&gt;...&lt;/div&gt; &lt;/transition&gt; `&#125;const Bar = &#123; template: ` &lt;transition name="fade"&gt; &lt;div class="bar"&gt;...&lt;/div&gt; &lt;/transition&gt; `&#125; 基于路由的动态过渡(Route-Based Dynamic Transition) 还可以基于当前路由与目标路由的变化关系，动态设置过渡效果： 1234&lt;!-- 使用动态的 transition name --&gt;&lt;transition :name="transitionName"&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 123456789// 接着在父组件内// watch $route 决定使用哪种过渡watch: &#123; '$route' (to, from) &#123; const toDepth = to.path.split('/').length const fromDepth = from.path.split('/').length this.transitionName = toDepth &lt; fromDepth ? 'slide-right' : 'slide-left' &#125;&#125; 查看完整例子请移步这里。 数据获取(Data Fetching) 有时候，进入某个路由后，需要从服务器获取数据(Sometimes you need to fetch data from the server when a route is activated) 例如，在渲染用户信息时，你需要从服务器获取用户的数据 滚动行为(Scroll Behavior)异步滚动(Async Scrolling)路由懒加载(Lazy Loading Routes)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-resource入门]]></title>
    <url>%2F2019%2F04%2F03%2Fvue-resource%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Vue-Resource入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue-resource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex 入门]]></title>
    <url>%2F2019%2F04%2F02%2FVuex%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Vuex安装123npm install vuex --save# 或者yarn add vuex Vuex 依赖 Promise ，如果你支持的浏览器并没有实现Promise(比如IE)，那么你可以使用一个polyfill的库，例如 es6-promise 安装 es6-promise 的方式是： 123npm install es6-promise --save # npm # 或者yarn add es6-promise 123// 然后或者更进一步，将下列代码添加到你使用Vuex之前的一个地方import 'es6-promise/auto'import Vue from 'vue' Vuex是什么(What is Vuex) Vuex 是一个专为Vue.js应用程序开发的 状态管理模式 (Vuex is a state management pattern + library for Vue.js applications)。 它采用 集中式存储 管理应用的所有组件的 状态 (It serves as a centralized store for all the components in an application)，并以相应的规则 来保证状态以一种可预测的方式 发生变化。 Vuex也集成到Vue的官方调试工具 devtools extension ，提供了诸如零配置的time-travel调试、状态快照导入导出等高级调试功能。 什么是“状态管理模式”？让我们从一个简单的Vue计数应用开始： 123456789101112131415161718new Vue(&#123; // state data()&#123; return &#123; count: 0 &#125; &#125;, // view template: '&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;', //actions methods: &#123; increment()&#123; this.count++ &#125; &#125;&#125;) 这个状态自管理应用包含以下几个部分： state，驱动应用的数据源(the source of truth that drives our app)； view，以声明方式将 state 映射到视图(a declarative mapping of the state)； actions，响应在 view 上的用户输入导致的状态变化； 下面是一个表示“单向数据流(one-way data flow”理念的简单示意 然而，当我们的应用遇到 多个组件共享状态 时，单向数据流的简洁性容易被破坏。 12345/**破坏单向数据流的两种问题如下：① 多个视图(view)依赖于同一个状态(state)② 来自不同视图(view)的行为(actions)需要变更同一状态(state)*/ 对于问题①，传参(passing props)的方法对于 多层嵌套的组件(deeply nested components) 将会非常繁琐，并且对于 兄弟组件间的状态传递 无能为力。 对于问题②，我们经常会采用 父子组件 直接引用 或 通过事件来变更和同步状态的多份拷贝。 在2/3中的这些模式非常脆弱，通常会导致无法维护的代码。 因此，我们为什么不把 组件的共享状态(the shared state out of the components) 抽离出来，以一个 全局单例模式(global singleton) 管理呢? 在这种 全局单例模式 下，我们的组件树构成了一个巨大的“视图(view)”，不管在树的哪个位置，任何组件都能获取状态(state) 或者 触发行为(actions)。 通过 定义(defining) 和 隔离(separating) 状态管理中的各种概念，并通过 强制规则(enforcing rules) 维持视图(view)和状态(state)间的独立性，我们的代码将会变得更结构化且易维护。 5/6/7所讲的就是Vuex背后的基本思想，借鉴了 Flux，Redux 和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js设计的状态管理库，以利用Vue.js的 细粒度数据响应机制 来进行高效的状态更新。 什么情况下应该使用Vuex？ Vuex可以帮助我们管理共享状态(deal with shared state management)，并附带了更多的概念和框架 Vuex适合开发中大型单页应用。 如果您的应用够简单，最好不要使用Vuex，一个简单的 store模式 就足够您所需了。 开始 每一个Vuex应用的核心就是 store(仓库) store基本上就是一个容器，它包含着您的应用中大部分的 状态(state)。 Vuex和单纯的全局对象有以下两点不同： 1234/**① Vuex的状态存储 是响应式的。当Vue组件从store中读取状态时，若store中的状态发生变化，那么相应的组件也会得到高效的更新。② 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地--提交mutation--。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。*/ 最简单的storeNote：我们将在后续的文档示例代码中使用ES2015语法。如果你还没能掌握ES2015，你得抓紧了 安装Vuex之后，我们首先来创建一个store。创建过程直截了当——仅需要提供一个初始state对象和一些mutation： 12345678910111213// 如果在 模块化构建系统 中，请确保在开头调用了 Vue.use(Vuex)// Vue.use(Vuex)const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125; &#125;&#125;) 现在，你可以通过 store.state 来 获取及访问状态对象(access the state object)，以及通过 store.commit 触发状态变更(trigger a state change)： 12345// 获取 及 访问状态对象console.log(store.state.count)// 触发状态变更store.commit('increment') 再次强调，我们通过提交mutation的方式，而非直接改变 store.state.count，是因为我们想要更明确地追踪(track)到状态的变化。——这是一个简单的约定，能够让你的意图更加明显，这样你在阅读代码的时候能更容易地解读应用内部的状态改变。 此外，这样也让我们有机会去实现一些能记录每次状态改变，保存状态快照的调试工具。 由于store中的状态时响应式的，在组件中调用store中的状态简单到仅需要在 计算属性 中返回即可。 123456789101112131415161718192021222324252627282930// main.jsimport Vue from 'vue'import App from './App'import Vuex from 'vuex'/** 通过store选项，提供了一种机制：将状态(state)从 根组件 注入到 每个子组件中。就需要调用 Vue.use(Vuex)*/Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++; &#125;, decrement(state)&#123; state.count--; &#125; &#125;&#125;)var vm = new Vue(&#123; el: '#app', components: &#123;App&#125;, template: '&lt;/App&gt;', store: store // 把 store 对象提供给 store 选项，这样可以把 store 实例注入到所有的子组件中&#125;) 触发变化也仅仅是在组件中的methods中提交mutation。 123456789101112131415161718192021export default&#123; name: "my", data: function()&#123; ... &#125;, computed: &#123; count: function()&#123; // 作为子组件，可以通过 this.$store 访问到 根实例中 注册的store选项 return this.$store.state.count； &#125; &#125;， methods: &#123; addCount()&#123; this.$store.commit('increment'); // 杜绝使用 this.$store.state.count = this.$store.state.count + 1 &#125;, subCount()&#123; this.$store.commit('decrement'); &#125; &#125;&#125; 接下来，我们将会更深入地探讨一些核心概念。让我们先从 State 开始吧。 核心概念State单一状态树(Single State Tree) Vuex 使用 单一状态树(Single State Tree)，也就是用一个对象就包含了全部的应用层级状态(contains all your application level state)，作为一个“唯一的数据源(SSOT，Single source of truth)”而存在。 这也意味着，每个应用将仅仅包含一个store实例(have one store for each application)。 单一状态树 让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。 单状态树和模块化并不冲突——在后面的章节里，我们会讨论如何将 状态和状态变更事件 分布到各个子模块中。 在Vue组件中获得Vuex状态(Getting Vuex State into Vue Components) 那么我们如何 在Vue组件中展示状态呢(How do we display state inside the store in our Vue components)？ 由于Vuex的状态存储是响应式的(Since Vuex stores are reactive)，从store实例中读取状态的最简单的方法就是在 计算属性 中返回某个状态(state)： 123456789// 创建一个Counter组件const Counter = &#123; template: '&lt;div&gt;&#123;&#123; count&#125;&#125;&lt;/div&gt;', computed: &#123; count()&#123; return store.state.count; &#125; &#125;&#125; 每当 store.state.count 变化的时候，都会重新求取计算属性，并且触发更新相关联的DOM。 然而，这种模式导致 组件依赖全局状态单例(the component to rely on the global store singleton) 在模块化的构建系统中，在每个需要使用state的组件中需要频繁地导入，并且在测试组件中需要模拟状态。 Vuex通过 store 选项，提供了一种机制将状态从根组件“注入”到每一个子组件中(需要调用 Vue.use(Vuex))： 1234567const app = new Vue(&#123; el: '#app', // 把 store 对象提供给store选项，这可以把store的实例注入所有的自组件中 store, components: &#123;Counter&#125;, template: '&lt;div class="app"&gt; &lt;counter&gt;&lt;/counter&gt; &lt;/div&gt;'&#125;) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下所有的子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： 12345678const Counter = &#123; template: '&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;', computed: &#123; count()&#123; return this.$store.state.count; &#125; &#125;&#125; mapState辅助函数(Helper) 当 一个组件 需要获取 多个状态(state) 时(When a component needs to make use of multiple store state properties or getters)，将这些 状态(state) 都声明为 计算属性 会有些重复和冗余。 为了解决1中的问题，我们可以使用 mapState 辅助函数帮助我们 生成计算属性，让开发者 少按几次键 ： 1234567891011121314151617181920212223// 在单独构建的版本中，辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default&#123; // ... data()&#123; return &#123; localCount: 0 &#125; &#125;, computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 ’count' 等同于 'state =&gt; state.count' countAlias: 'count', // 为了能够使用 this 获取局部状态(local state), 必须使用常规函数 countPlusLocalState(state)&#123; return state.count + this.localCount &#125; &#125;)&#125; 当 映射的计算属性的名称 与 state的子节点名称相同时，我们也可以给 mapState 传一个字符串数组： 1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 对象展开运算符(Object Spread Operator) mapState 函数返回的是一个 对象。我们如何将它与 局部计算属性(local computed) 混合使用呢? 通常，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。 但是自从有了 对象展开运算符 (现处于 ECMAScript 提案stage-4阶段)，我们可以极大地简化写法： 123456789computed: &#123; localComputed()&#123; &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; &#125;)&#125; 组件仍然保有局部状态(Components Can Still Have Local State) 使用Vuex并 不意味着你需要将 所有的状态 放入Vuex。 虽然将所有的状态放到Vuex会使状态变化更显式和易调试，但也会使代码变得冗长和不直观。 如果有些状态严格属于单个组件，最好还是作为组件的局部状态(as local state)。 您应该根据您的 应用开发需要 进行权衡。 Getter 有时，我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数： 12345computed: &#123; doneTodosCount()&#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length; &#125;&#125; 如果有多个组件需要用到此属性，我们要么复制这个函数，或者抽取到一个共享函数然后在多处导入它——这两种方式，无论哪种方式，都不是很理想。 Vuex允许我们在 store 中定义“getter”(可以认为是store的计算属性)。 就像 计算属性 一样，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 Getter接受state作为其第一个参数： 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123;id: 1, text: '...', done: true &#125;, &#123;id: 2, text: '...', done: false&#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 通过属性访问(Property-Style Access) Getter 会暴露为 store.getters 对象(The getters will be exposed on the store.getters object)，你可以以属性的形式访问这些值： 12store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getter 也可以 接受其他getter 作为第二个参数： 12345678910111213getters: &#123; // ... doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;/**store.getters.doneTodosCount// -&gt; 1*/ 我们可以很容易地在任何组件中使用它： 12345computed:&#123; doneTodosCount()&#123; return this.$store.getters.doneTodosCount &#125;&#125; 注意，getter在通过属性访问时，是作为Vue响应式系统的一部分缓存其中的(Note that getters accessed as properties are cached as part of Vue’s reactivity system)。 通过方法访问(Method-Style Access) 你也可以通过让 getter 返回一个函数，来实现给 getter 传参。 在你对 store 里的数组进行查询时非常有用。 12345678910111213getters: &#123; // ... getTodoById: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125;/**store.getters.getTodoById(2)// -&gt; &#123; id: 2, text: '...', done: false &#125;*/ 注意，getter在通过方法访问时，每次都会去进行调用，而不会缓存结果。 mapGetters辅助函数(Helper) mapGetters 辅助函数仅仅是将store中的getter映射到局部计算属性(local computed)： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default&#123; // ... computed: &#123; // 使用对象展开符将 getter 混入到 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式： 1234mapGetters(&#123; // 把 this.doneCount 映射为 this.$store.getters.doneTodosCount doneCount: 'doneTodosCount'&#125;) Mutation 更改 Vuex 的 store 中的状态的唯一方法是 提交 mutation (The only way to actually changes state in a Vuex store is by committing a mutation)。 Vuex中的mutation非常类似于事件(Vuex mutations are very similar to events)：每个mutation都有一个 字符串事件类型(type) 和 一个 处理函数(handler)。 这个处理函数就是我们实际进行状态更改的地方，并且它会接受state作为第一个参数： 123456789101112const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; // 每个mutation中的handler会接受state作为第一个参数 increment(state)&#123; // 变更状态 state.count++ &#125; &#125;&#125;) 你 不能 直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。” 要唤醒一个 mutation handler，你需要以相应的type调用store.commit方法： 12// 像这样store.commit('increment') 提交载荷(Commit with Payload) 你可以向 store.commit 传入额外的参数，即mutation的载荷(payload): 123456789101112// ...mutations: &#123; increment( state, n)&#123; state.count += n; &#125;&#125;/** store.commit('increment', 10)*/ 在大多数情况下，载荷应该是 一个对象，这样 可以包含多个字段 并且记录的mutation会更易读： 1234567891011121314// ...mutations: &#123; increment(state, payload)&#123; state.count += payload.amount &#125;&#125;/**store.commit('increment', &#123; amount: 10&#125;)*/ 对象风格的提交方式(Object-Style Commit) 提交mutation的另一种方式是直接使用包含 type 属性的 对象： 1234store.commit(&#123; type: 'increment', amount: 10&#125;) 当使用对象风格的提交方式时，整个对象都作为载荷传给mutation，因此handler保持不变： 12345mutations:&#123; increment(state, payload)&#123; state.count += payload.amount &#125;&#125; Mutations 需遵守Vue的响应规则(Mutations Follow Vue Reactivity Rules) 既然Vuex的store中状态(state)是响应式的，那么当我们变更状态(mutate the state)时，监视状态(observing the state)的Vue组件也会自动更新。 这也意味着Vuex中的mutation也需要与使用Vue一样遵守一些注意事项(Caveats) 123456// 注意事项① 最好提前在你的 store 中初始化好所有所需属性。② 当需要在对象上添加新属性时，你应该： * 使用Vue.set(obj, 'newProp', 123), 或者 * 以新对象替换老对象。例如，利用stage-3的对象展开运算符，我们可以这样写： state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代Mutation事件类型(Using Constants for Mutation Types) 使用常量替代 mutation 事件类型(mutation types)在各种Flux实现中是非常常见的模式。 这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以你的代码合作者对整个app包含的mutation一目了然。 12// mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION' 12345678910111213// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用ES2015风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state)&#123; // mutate state &#125; &#125;&#125;) 用不用常量取决于你——在需要多人协作的大型项目中，这会很有帮助。但如果你不喜欢，你完全可以不这样做。 Mutaiton必须是同步函数(Synchronous) 一条重要的原则就是要记住 mutation 必须是同步函数 。 123456789101112131415mutations:&#123; someMutation(state)&#123; api.callAsyncMethod(() =&gt; &#123; state.count++ &#125;) &#125;&#125;/**现在想象，我们正在 debug 一个 app 并且观察 devtool 中的 mutation 日志。每一条 mutation 被记录，devtools 都需要捕捉到前一状态和后一状态的快照。然而，在上面的例子中 mutation 中的异步函数中的回调让这不可能完成：因为当 mutation 触发的时候，回调函数还没有被调用，devtools 不知道什么时候回调函数实际上被调用——实质上任何在回调函数中进行的状态的改变都是不可追踪的*/ 在组件中提交Mutation(Committing Mutations in Components) 你可以在组件中使用 this.$store.commit(&#39;xxx&#39;) 提交mutation，或者使用 mapMutations 辅助函数将组件中的methods映射为 store.commit 调用(需要在根节点注入store) 123456789101112131415161718192021import &#123; mapMutations &#125; from 'vuex'export default&#123; // ... methods: &#123; ...mapMutations([ // 将 this.increment() 映射为 this.$store.commit('increment') 'increment', // mapMutations 也支持载荷: // 将 this.incrementBy(amount) 映射为 // this.$store.commit('incrementBy', amount) 'incrementBy' ]), ...mapMutations(&#123; // 将 this.add() 映射为 this.$store.commit('increment') add: 'increment' &#125;) &#125;&#125; 下一步：Actions(On to Actions) 在mutation中 混合异步调用 会导致你的程序很难调试。 例如，当你调用了两个包含异步回调的mutation来改变状态(state),你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。 在Vuex中，mutation都是 同步事务： 12store.commit('increment')// 任何由 increment 导致的状态变更都应该在此刻完成 为了处理异步操作，让我们来看看Action。 ActionAction类似于mutation，不同在于： Action 提交的是mutation，而不是直接变更状态(mutate state) Action 可以包含任意异步操作 让我们来注册一个简单的action： 12345678910111213141516const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; state.count++ &#125; &#125;, actions: &#123; // Actions函数接受一个与store实例具有相同方法和属性的context对象 increment(context)&#123; context.commit('increment') &#125; &#125;&#125;) Action函数接受一个与store实例 具有相同方法和属性的context对象 (Action handlers receive a context object which exposes the same set of methods/properties on the store instance)。 因此你可以调用 context.commit 提交一个mutation， 或者通过 context.state 和 context.getters 来获取 state 和 getters。 当我们在之后介绍到 Modules 时，你就知道context对象为什么不是store实例本身了。 实践中，我们会经常用到ES2015的 参数解构 来简化代码(特别是我们需要调用 commit 很多次的时候)： 12345actions: &#123; increment(&#123; commit &#125;)&#123; commit('increment') &#125;&#125; 分发Action(Dispatching Actions)Action 通过 store.dispatch 方法触发： 1store.dispatch('increment') 乍一眼看上去感觉多次一举，我们直接分发mutation岂不是更方便？实际上并非如此，还记得 mutation 必须同步执行 这个限制么? Action 就不受约束！我们可以在action内部执行 异步操作： 1234567actions: &#123; incrementAsync(&#123; commit &#125;)&#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Actions 支持同样的载荷方法和对象方式进行分发(Actions support the same payload format and object-style dispatch)： 12345678910// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 来看一个更加实际的 购物车示例，涉及到 调用异步API 和 分发多重mutation ： 12345678910111213141516171819actions: &#123; checkout(&#123; commit, state &#125;, products)&#123; // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物API接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =&gt; commit(types.CHECKOUT_SUCCESS), // 失败操作 () =&gt; commit(types.CHECKOUT_FAILURE, savedCartItems) ) &#125;&#125; 注意在4中，我们正在进行一系列异步操作，并且通过提交 mutation 来记录 action 产生的状态变更(state mutate) 在组件中分发Action 你在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发action。 或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用(需要先在根节点注入 store ) 123456789101112131415161718import &#123; mapActions &#125; from 'vuex'export default&#123; // ... methods: &#123; ...mapActions([ //将this.increment()映射为 this.$store.dispatch('increment') 'increment', // `mapActions` 也支持载荷： 'incrementBy' ]), ...mapActions(&#123;// 将 `this.add()` 映射为 `this.$store.dispatch('increment')` add: 'increment' &#125;) &#125;&#125; 组合Action(Composing Actions) Action 通常是异步的，那么如何知道actions什么时候结束呢？ 更重要的是，我们如何才能组合多个action，以处理更加复杂的异步流程？ 首先你需要明白 store.dispatch 可以处理 被触发的action的处理函数 返回的Promise，并且 store.dispatch 仍旧返回 Promise ： 12345678910actions:&#123; actionA(&#123;commit&#125;)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 现在你可以： 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另外一个action中也可以： 12345678actions: &#123; // ... actionB(&#123;dispatch, commit&#125;)&#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 最后，如果我们利用 async / await，我们可以如下组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。 Module 由于使用单一状态树(Due to using a single state tree)，应用的所有状态会集中到一个比较大的对象。 当应用变得非常复杂时，store对象就有可能变得相当臃肿。 为了解决以上问题，Vuex允许我们将store分割成 模块(module) 。 每个模块拥有自己的state、mutation、action、getter、甚至是嵌套子模块——从上而下进行同样方式的分割： 1234567891011121314151617181920const moduleA = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;, getters: &#123; ... &#125;&#125;const moduleB = &#123; state: &#123; ... &#125;, mutations: &#123; ... &#125;, actions: &#123; ... &#125;&#125; const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt; moduleA 的状态store.state.b // -&gt; moduleB 的状态 模块的局部状态(Module Local State) 对于模块内部的mutation和getter，接收的第一个参数是 模块的局部状态对象。 12345678910111213141516const moduleA = &#123; state: &#123; count: 0 &#125;, mutations: &#123; increment(state)&#123; // 这里 state对象是模块的局部状态 state.conut++ &#125; &#125;, getters: &#123; doublueCount(state)&#123; return state.count * 2 &#125; &#125;&#125; 同样，对于模块内部的action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState ： 12345678910const moduleA = &#123; // ... actions: &#123; incrementIfOddOnRootSum(&#123; state, commit, rootState &#125;) &#123; if((state.count + rootState.count) % 2 === 1)&#123; commit('increment') &#125; &#125; &#125;&#125; 对于模块内部的getter，根节点状态会作为第三个参数暴露出来： 12345678const moduleA = &#123; // ... getters: &#123; sumWithRootCount(state, getters, rootState)&#123; return state.count + rootState.count &#125; &#125;&#125; 命名空间(Namespacing) 默认情况下，模块内部的action、mutation和getter是注册在 全局命名空间 的 这样使得多个模块能够对同一 mutation 或 action 做出响应 如果希望你的模块具有更高的 封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。 当模块被注册后，它的所有 getter、 action 及 mutation 都会自动根据模块注册的路径调整命名。例如： 12345678910111213141516171819202122232425262728293031323334353637383940const store = new Vuex.Store(&#123; modules: &#123; account: &#123; namespaced: true, // 模块内容（module assets） state: &#123; ... &#125;, // 模块内的状态已经是嵌套的了，使用 `namespaced` 属性不会对其产生影响 getters: &#123; isAdmin () &#123; ... &#125; // -&gt; getters['account/isAdmin'] &#125;, actions: &#123; login () &#123; ... &#125; // -&gt; dispatch('account/login') &#125;, mutations: &#123; login () &#123; ... &#125; // -&gt; commit('account/login') &#125;, // 嵌套模块 modules: &#123; // 继承父模块的命名空间 myPage: &#123; state: &#123; ... &#125;, getters: &#123; profile () &#123; ... &#125; // -&gt; getters['account/profile'] &#125; &#125;, // 进一步嵌套命名空间 posts: &#123; namespaced: true, state: &#123; ... &#125;, getters: &#123; popular () &#123; ... &#125; // -&gt; getters['account/posts/popular'] &#125; &#125; &#125; &#125; &#125;&#125;) / 待续 / 在带命名空间的模块内访问全局内容(Global Assets)项目结构(Application Structure)Vuex并不限制你的代码结构。但是它规定了一些需要遵守的规则： 应用层级的状态应该集中到单个 store 对象中。 提交 mutation 时更改状态的唯一方法，并且这个过程是同步的。 异步逻辑都应该封装到 action 里面 只要你遵守以上规则，如何组织代码随你便。如果你的store文件太大，只需将action、mutation和getter分割到单独的文件中去。 对于大型应用，我们会希望把Vuex相关代码分割到模块中，下面是项目结构实例： 1234567891011121314├── index.html├── main.js├── api│ └── ... # 抽取出API请求├── components│ ├── App.vue│ └── ...└── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 请参考购物车实例。 插件(Plugins) Vuex的store接受 plugins 选项，这个选项暴露出每次 mutation 的钩子。 Vuex插件就是一个函数，它接收store作为唯一的参数： 1234567const myPlugin = store =&gt; &#123; // 当store初始化后调用 store.subscribe((mutation, state) =&gt; &#123; // 每次 mutation 之后调用 // mutation的格式为 &#123; type, payload &#125; &#125;)&#125; 然后像这样使用： 1234const store = new Vuex.Store(&#123; // ,,, plugins: [myPlugin]&#125;) 在插件内提交Mutation(Committing Mutations Inside Plugins) 在插件中不允许直接修改状态(mutate state)——类似于组件，只能通过提交mutation来触发变化(only trigger changes by committing mutations) 通过提交mutation，插件可以用来同步数据源到store。 例如同步websocket数据源到store（下面是个大概例子，实际上 creatPlugin 方法可以有更多选项来完成复杂任务）： 123456789101112export default function createWebSocketPlugin (socket) &#123; return store =&gt; &#123; socket.on('data', data =&gt; &#123; store.commit('receiveData', data) &#125;) store.subscribe(mutation =&gt; &#123; if (mutation.type === 'UPDATE_DATA') &#123; socket.emit('update', mutation.payload) &#125; &#125;) &#125;&#125; 1234567const plugin = createWebSocketPlugin(socket)const store = new Vuex.Store(&#123; state, mutations, plugins: [plugin]&#125;) 生成State快照(Taking State Snapshots) 有时候插件需要获得状态的“快照”，比较改变的前后状态。 想要实现这项功能，你需要对状态对象进行深拷贝： 1234567891011const myPluginWithSnapshot = store =&gt; &#123; let prevState = _.cloneDeep(store.state) store.subscribe((mutation, state) =&gt; &#123; let nextState = _.cloneDeep(state) // 比较 prevState 和 nextState... // 保存状态，用于下一次 mutation prevState = nextState &#125;)&#125; 生成状态快照的插件应该只在开发阶段使用，使用 webpack 或 Browserify，让构建工具帮我们处理： 123456const store = new Vuex.Store(&#123; // ... plugins: process.env.NODE_ENV !== 'production' ? [myPluginWithSnapshot] : []&#125;) 上面插件会默认启用。在发布阶段，你需要使用 webpack 的 DefinePlugin 或者是 Browserify 的 envify 使 process.env.NODE_ENV !== &#39;production&#39; 为 false。 内置Logger插件(Built-in Logger Plugin) 如果正在使用 vue-devtools，你可能不需要此插件。 Vuex 自带一个日志插件用于一般的调试: 12345import createLogger from 'vuex/dist/logger'const store = new Vuex.Store(&#123; plugins: [createLogger()]&#125;) createLogger 函数有几个配置项： 12345678910111213141516171819const logger = createLogger(&#123; collapsed: false, // 自动展开记录的 mutation filter (mutation, stateBefore, stateAfter) &#123; // 若 mutation 需要被记录，就让它返回 true 即可 // 顺便，`mutation` 是个 &#123; type, payload &#125; 对象 return mutation.type !== "aBlacklistedMutation" &#125;, transformer (state) &#123; // 在开始记录之前转换状态 // 例如，只返回指定的子树 return state.subTree &#125;, mutationTransformer (mutation) &#123; // mutation 按照 &#123; type, payload &#125; 格式记录 // 我们可以按任意方式格式化 return mutation.type &#125;, logger: console, // 自定义 console 实现，默认为 `console`&#125;) 日志插件还可以直接通过 &lt;script&gt; 标签引入，它会提供全局方法 createVuexLogger。 要注意，logger 插件会生成状态快照，所以仅在开发环境使用。 严格模式(Strict Mode)开启严格模式，仅需在创建store的时候传入 strict: true ： 1234const store = new Vuex.Store(&#123; // ... strict: true&#125;) 在严格模式下，无论何时发生了状态变更 且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更 都能被调试工具跟踪到。 开发环境与发布环境(Dev vs Prod) 不要在发布环境下启用严格模式 严格模式会深度监测状态树 来检测不合格的状态变更 请确保在Production环境下关闭严格模式，以避免性能损失 类似于插件，我们可以让 构建工具(the build tools) 来处理这种情况： 1234const store = new Vuex.Store(&#123; // ... strict: process.env.NODE_ENV !== 'production'&#125;) 表单处理(Form Handling) 当在严格模式中使用Vuex时，在属于Vuex的state上使用 v-model 会比较棘手： 1&lt;input v-model="obj.message"&gt; 假设这里的 obj 是计算属性中返回的一个属于Vuex store的对象，在用户输入时，v-model 会试图直接修改 obj.message 。 在严格模式中，由于这个修改不是在mutation函数中执行的，这里会抛出一个错误 用Vuex的思维 去解决这个问题的方法是：给 中绑定value，然后侦听 input 或者 change 事件，在事件回调中调用 action： 1&lt;input :value="message" @input="updateMessage"&gt; 1234567891011// ...computed: &#123; ...mapState(&#123; message: state =&gt; state.obj.message &#125;)&#125;，methods: &#123; updateMessage(e)&#123; this.$store.commit('updateMessage', e.target.value) &#125;&#125; 123456// 下面是mutation函数mutations: &#123; updateMessage(state, message)&#123; state.obj.message = message &#125;&#125; 双向绑定的计算属性 必须承认，这样做比较简单地使用 v-model +局部状态 要啰嗦的多，并且也损失了一些v-model 中很有用的特性。 另一方法是使用带有setter的双向绑定计算属性： 1&lt;input v-model="message"&gt; 123456789101112// ...computed:&#123; message:&#123; get()&#123; return this.$store.state.obj.message &#125;， set(value)&#123; this.$store.commit('updateMessage', value) &#125; &#125;&#125; 测试(Testing)暂时详见 测试 热重载(Hot Reloading)暂时详见 热重载]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件处理(Event Handling)]]></title>
    <url>%2F2019%2F04%2F02%2F%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[监听事件(Listening to Events) 可以用 v-on 指令监听DOM事件，并在触发时运行一些JavaScript代码 12345678&lt;div id="example-1"&gt; &lt;button v-on:click="counter += 1"&gt; Add 1 &lt;/button&gt; &lt;p&gt; The button above has been clicked &#123;&#123; counter &#125;&#125; times. &lt;/p&gt;&lt;/div&gt; 123456var example1 = new Vue(&#123; el: '#example-1', data: &#123; counter: 0 &#125;&#125;) 事件处理方法(Method Event Handlers) 然而许多事件处理(event handlers)逻辑会更复杂，所以直接把JavaScript代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称 123456&lt;div id="example-2"&gt; &lt;!-- greet 是下面定义的方法名 --&gt; &lt;button v-on:click="greet"&gt; Greet &lt;/button&gt;&lt;/div&gt; 123456789101112131415161718192021var example2 = new Vue(&#123; el: '#example-2', data: &#123; name: 'Vue.js' &#125;, // 在methods对象中定义方法 methods: &#123; greet: function(event)&#123; // this 指向当前Vue实例 alert('Hello' + this.name + '!'); // event 是原生DOM事件 if(event)&#123; alert(event.target.tagName) &#125; &#125; &#125;&#125;)// 也可以用JavaScript直接调用方法example2.greet() // =&gt; 'Hello Vue.js' 内联处理器中的方法(Methods in lnline Handlers) 除了直接绑定到一个方法，也可以在内联JavaScript语句中调用方法： 12345678&lt;div id="example-3"&gt; &lt;button v-on:click="say('hi')"&gt; Say hi &lt;/button&gt; &lt;button v-on:click="say('what')"&gt; Say what &lt;/button&gt;&lt;/div&gt; 12345678new Vue(&#123; el: 'example-3', methods:&#123; say: function(message)&#123; alert(message) &#125; &#125;&#125;) 有时也需要在内联语句处理器中访问原始的DOM事件。可以用特殊变量 $event 把它传入方法： 123&lt;button v-on:click="warn('Form cannot be submitted yet.', $event)"&gt; Submit&lt;/button&gt; 12345678910// ...methods: &#123; warn: function(message, event)&#123; // 现在我们可以访问原生事件对象 if(event)&#123; event.preventDefault() &#125; alert(message) &#125;&#125; 事件修饰符(Event Modifiers) 在事件处理程序中(inside event handlers) 调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。 尽管我们可以在方法中(inside methods)轻松实现这点，但更好的方式是：方法(methods)只有纯粹的数据逻辑，而不是去处理DOM事件细节。 为了1/2中的问题，Vue.js为 v-on 提供了 事件修饰符 。之前提过，修饰符是由点开头的指令后缀来表示的： .stop .prevent .capture .self .once .passive 12345678910111213141516&lt;!-- 阻止单击事件继续传播 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 这段代码，点击button时，将先执行 doThis方法、再执行 dodo方法 --&gt;&lt;div v-on:click="dodo"&gt; &lt;button v-on:click="doThis"&gt; 阻止单击事件继续传播 &lt;/button&gt;&lt;/div&gt;&lt;!-- 点击button时，只执行 doThis方法 --&gt;&lt;div v-on:click="dodo"&gt; &lt;button v-on:click.stop="doThis"&gt; 阻止单击事件继续传播 &lt;/button&gt;&lt;/div&gt; 123456789101112131415161718&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt; ...&lt;/form&gt;&lt;div id="hdcms"&gt;&lt;!-- 方式一：使用$event原生操作 --&gt;&lt;form action='' @submit="post1('hdphp', $event)"&gt; &lt;h1&gt;&#123;&#123; times &#125;&#125;&lt;/h1&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;!-- 方式二:使用修饰符.prevent [推荐使用该方法] --&gt;&lt;form action='' @submit.prevent="post2('hdphp)"&gt; &lt;h1&gt;&#123;&#123; times &#125;&#125;&lt;/h1&gt; &lt;button&gt;提交&lt;/button&gt;&lt;/form&gt; &lt;/div&gt; 123456789101112131415161718var app = new Vue(&#123; el: '#hdcms', data: &#123; times: new Date() &#125;, methods: &#123; // 方式一： 原生操作 post1(num, event)&#123; event.preventDefault(); //阻止默认刷新页面提交 alert(num); &#125;, // 方式二：修饰符操作 post2(num)&#123; alert(num); &#125; &#125;&#125;) 12&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt; 1234&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt; ...&lt;/form&gt; 12345&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture="doThis"&gt; ...&lt;/div&gt; 12345&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self="doThat"&gt; ...&lt;/div&gt; 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此：用 v-on:click.prevent.self 会阻止 所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击 .once [V 2.1.4 新增]，不像其它 只能对原生DOM事件起作用的修饰符， .once 修饰符还能被用到自定义的 组件事件 上。 1234&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once="doThis"&gt; ...&lt;/a&gt; 不像其它只能对原生的DOM事件起作用的修饰符， once 修饰符还能被用到自定义的 组件事件 上。 V 2.3.0 新增：Vue还对应 addEventListener 中的 passive 选项提供了.passive 修饰符。 12345678&lt;!-- 滚动事件的默认行为(即滚动行为)将会立即出发 --&gt;&lt;!-- 而不会等待 onScroll 完成 --&gt;&lt;!-- 这其中包含 event.preventDefault() 的情况 --&gt;&lt;div v-on:scroll.passive="onScroll"&gt; ...&lt;/div&gt;&lt;!-- 这个 .passive 修饰符尤其能够提升移动端的性能 --&gt; 12345/**不要把 .passive 和 。prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住， .passive 会告诉浏览器你 不想 阻止事件的默认行为。*/ 按键修饰符(Key Modifiers) 在监听键盘事件时，我们经常需要检查详细的按键。 Vue允许为 v-on 在监听键盘事件时添加按键修饰符： 12&lt;!-- 只有在 key 是 Enter 时调用 vm.submit() --&gt;&lt;input v-on:keyup.enter="submit"&gt; 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名 转换为 kebab-case 来作为修饰符 1&lt;input v-on:keyup.page-down="onPageDown"&gt; 在上述示例中，处理函数只会在 $event.key 等于 PageDown 时被调用。 按键码(Key Codes) keyCode 的事件用法 已经被废弃 了并可能不会被最新的浏览器支持。 使用 keyCode 特性(attributes) 是允许的： 1&lt;input v-on:keyup.13="submit"&gt; 为了在必要的情况下支持旧浏览器，Vue提供了绝大多数常用的按键码别名： 123456789* .enter* .tab* .delete（捕获‘删除’和‘退格’键)* .esc* .space* .up* .down* .left* .right 有些按键（ .esc 以及所有的方向键）在IE9中有不同的 key 值，如果你想支持 IE9，上面这些内置的别名应该是首选的。 你还可以通过全局 config.keyCodes 对象 自定义按键修饰符别名 ： 12// 可以使用 v-on:keyup.f1Vue.config.keyCode.f1 = 112 系统修饰键(System Modifier Keys) [V2.1.0新增] 可以用如下修饰符来实现 仅在按下相应按键时 才触发鼠标或键盘事件的监听器 1234* .ctrl* .alt* .shift* .meta 注意：在Mac系统键盘上，meta对应command键；在Windows系统键盘上meta对应Windows徽标键；在Sun操作系统键盘上，meta赌赢实心宝石键。在其他特定键盘上，尤其是在MIT和Lisp机器的键盘、以及其后继产品，比如Knight键盘、space-cadet键盘，meta被标记为“META”。在Symbolics键盘上，meta被标记为“META”或“Meta。 1234567&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt; Do Something&lt;/div&gt; 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符 [V2.5.0新增] .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt; 鼠标按钮修饰符(Mouse Button Modifiers) [V2.2.0 新增] 1234* .left* .right* .middle这些修饰符会限制处理函数仅响应特定的鼠标按钮。 为什么在HTML中监听事件你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何清理它们。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js入门]]></title>
    <url>%2F2019%2F03%2F30%2FNode-js%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Node.js入门]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web Components入门]]></title>
    <url>%2F2019%2F03%2F30%2FWeb-Components%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Web Components入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Web Components</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP入门]]></title>
    <url>%2F2019%2F03%2F30%2FHTTP%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTTP入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS入门]]></title>
    <url>%2F2019%2F03%2F30%2FCSS%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[CSS入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML入门]]></title>
    <url>%2F2019%2F03%2F30%2FHTML%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[HTML入门]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript入门]]></title>
    <url>%2F2019%2F03%2F30%2FJavaScript%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[快速入门 JavaScript 是一种具有函数优先的轻量级 解释型(interpreted) 或 即时编译型(Just-In-Time) 的编译语言。 虽然它是作为 开发Web页面 的脚本语言而出名，但是它也被用到了 很多非浏览器环境中，例如 Node.js、Apache CouchDB 和 Adobe Acrobat JavaScript是一种基于 原型编程(Prototype-Based)、多范式(Multi-Paradigm)的动态脚本语言，并且支持面向对象(Object-Oriented)、命令式(Imperative)和声明式(Declarative)(如函数式编程)风格]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[列表渲染(List Rendering)]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[用v-for把一个数组对应成一组元素(Mapping an Array to Elements with v-for) 我们用 v-for 指令根据一组 数组的项目列表 进行渲染(We can use the v-for directive to render a list of items based on an array)。 v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组(the source data array)，item 是数组元素。 123&lt;ul id="example-1"&gt; &lt;li v-for="item in items"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 123456789var example1 = new Vue(&#123; el: '#example-1', data: &#123; items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 结果： Foo Bar 在 v-for 块中，我们拥有对父作用域属性(parent scope properties)的完全访问权限。v-for 还支持一个可选的第二个参数为当前项的索引。 12345&lt;ul id="example-2"&gt; &lt;li v-for="(item, index) in items"&gt; &#123;&#123; parentMessage &#125;&#125; - &#123;&#123; index &#125;&#125; - &#123;&#123; item.message &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910var example2 = new Vue(&#123; el: '#example-2', data: &#123; parentMessage: 'Parent', items: [ &#123; message: 'Foo' &#125;, &#123; message: 'Bar' &#125; ] &#125;&#125;) 结果： Parent - 0 - Foo Parent - 1 - Bar 你也可以用 of 替代 in 作为分隔符，因为它是最接近JavaScript迭代器的语法： 123&lt;div v-for="item of items"&gt; ...&lt;/div&gt; 一个对象的v-for(with an Object) 你可以用 v-for 通过 一个对象的属性(the properties of an object) 来迭代 12345&lt;ul id="v-for-object" class="demo"&gt; &lt;li v-for="value in object"&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910new Vue(&#123; el: '#v-for-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;) 结果： John Doe 30 你也可以提供第二个参数即键名： 123&lt;div v-for="(value, key) in object"&gt; &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 结果： 123firstName: JohnlastName: Doeage: 30 第三个参数为索引(index)： 123&lt;div v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; 结果： 1230. firstName:John1. lastName:Doe2. age: 30 在遍历对象(iterating over an object)时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的JavaScript引擎下是一致的。 key 当Vue.js用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略(When Vue is updating a list of elements rendered with v-for ，by default it uses an “in-place patch” strategy)。 即使数据项的顺序被改变(If the order of the data items has changed)，Vue将不会移动DOM元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 Vue默认的上述模式是高效的，但是只适用于 不依赖子组件状态或临时DOM状态(例如：表单输入值)的列表渲染输出。(This default mode is efficient, but only suitable when your list render output does not rely on child component state or temporary DOM state, e.g. form input values) 为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key属性。 理想的 key 值是每项都有唯一的 id，这个特殊的特性(attribute)相当于Vue 1.x的 track-by ，但它的工作方式类似于一个特性(attribute)，所以你需要用 v-bind 来绑定动态值(dynamic values)： 123&lt;div v-for="item in items" :key="item.id"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key ，除非遍历输出的DOM内容非常简单，或者是刻意依赖默认行为以获取性能上的提升 因为它是Vue识别节点的一个通用机制， key 并不与 v-for 特别关联，key 还具有其他用途，在后续的指南中我们将仍会看到它的用处 不要使用 对象 或 数组 之类的 非原始类型值 作为 v-for 的 key 。用 字符串 或 数字 类型的值取而代之 数组更新检测(Array Change Detection)变异方法(Mutation Methods) Vue包含一组观察数组的变异方法，所以它们也将会触发视图更新(Vue wraps an observed array’s mutation methods so they will also triiger view updates)。 这些方法(The wrapped methods)如下： 1**push()** **pop()** **shift()** **unshift()** **splice** **sort()** **reverse()** 打开控制台，然后用前面例子的 items 数组调用变异方法：`example1.items.push({ message: ‘Baz’ }) 替换数组(Replacing an Array) 变异方法(mutation method)会改变被这些方法调用的原始数组。 相比之下，也有非变异(non-mutating method)方法，例如：filter() 、concat() 和 slice() 。这些不会改变原始数组(which do not mutate the original array)，但 总是返回一个新数组。 当使用非变异方法时，可以用新数组替换旧数组： 123example1.items = example1.items.filter(function(item)&#123; return item.message.match(/Foo/)&#125;) 你可能认为这将导致 Vue 丢弃现有DOM并重新渲染整个列表 幸运的是，事实并非如此。 Vue为了使得DOM元素得到最大范围的重用而实现了一些智能、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作 注意事项(Caveats)由于JavaScript的限制，Vue 不能检测以下变动的数组： 第一类：当你利用索引直接设置一个项时(When you directly set an item with the index, e.g.)。如： 1vm.items[indexOfItem] = newValue 第二类：当你修改数组的长度时，例如 `vm.items.length = newLength 1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和 vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新： 12// Vue.setVue.set(vm.items, indexOfItem, newValue) 12345// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)// 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice ： 1vm.items.splice(newLength) 对象更改检测注意事项(Object Change Detection Caveats)由于JavaScript的限制，Vue不能检测对象属性的添加或删除 12345678var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// vm.a 现在是响应式的vm.b = 2// vm.b 不是响应式的 对于已经创建的实例，Vue不能动态添加根级别的响应式属性(Vue does not allow dynamically adding new root-level reactive properties to an already created instance) 但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象(a nested object)添加响应式属性(reactive properties)。例如： 1234567891011121314151617var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anike' &#125; &#125;&#125;)/*******************//**你可以添加一个新的age属性到嵌套的 userProfile 对象：Vue.set(vm.userProfile, 'age', 27)*//**你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：vm.$set(vm.userProfile, 'age', 27)*/ 有时候，你可能需要为已有对象赋予多个新属性(Sometimes you may want to assign a number of new properties to an existing object)。比如使用 Object.assign() 或 _.extend() 。在这种情况下，你应该用 两个对象的属性 创建一个新的对象。所以，如果你想添加新的响应式属性： 1234567891011// 不要像这样：Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;)// 应该这样做：Vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 显示过滤/排序结果(Displaying Filtered/Sorted Results) 有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建 返回过滤或排序数组 的计算属性 123&lt;li v-for="n in evenNumbers"&gt; &#123;&#123; n &#125;&#125;&lt;/li&gt; 12345678910data: &#123; numbers: [ 1, 2, 3, 4, 5]&#125;, computed: &#123; evenNumbers: function()&#123; return this.numbers.filter(function(number)&#123; return number % 2 === 0 &#125;) &#125; &#125; 在计算属性不适用的情况下(例如， 在嵌套 v-for 中)，你可以使用一个 method 方法???： 123&lt;li v-for="n in even(numbers)"&gt; &#123;&#123; n &#125;&#125;&lt;/li&gt; 12345678910data: &#123; numbers: [ 1, 2, 3, 4, 5]&#125;,methods: &#123; even: function(numbers)&#123; return numbers.filter(function(number)&#123; return number % 2 === 0 &#125;) &#125; &#125; 一段取值范围的v-for(with a Range) v-for 也可以取整数，在这种情况下，它将重复多次模板 1234&lt;div&gt; &lt;span v-for="n in 10"&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt;&lt;!-- 结果：1 2 3 4 5 6 7 8 9 10 --&gt; v-for on a &lt;template&gt; 类似于 v-if ，你也可以利用带有 v-for 的 &lt;template 渲染多个元素 123456&lt;ul&gt; &lt;template v-for="item in items"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class="divider" role="presentation"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for with v-if 我们不推荐同时使用 v-if 和 v-for，更多细节可查阅 风格指南 当两者处于同一节点，v-for 的优先级比v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 而当你想为仅有的 一些项() 渲染节点时，下面这种优先级的机制会十分有用： 1234&lt;li v-for="todo in todos" v-if="!todo.isComplete"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt;&lt;!-- 这段代码只传递了未完成的todos --&gt; 而如果你是想有条件地跳过循环的执行，那么可以将 v-if 置于外层元素(或 &lt;template&gt; 上)，如： 12345678&lt;ul v-if="todos.length"&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt; No todos left!&lt;/p&gt; 一个组件的v-for 在自定义组件里，你可以像任何普通元素一样用 v-for 12&lt;my-component v-for="item in items" :key="item.id"&gt;&lt;/my-component&gt;&lt;!-- 注意：在V2.2.0+版本里，当在组件中使用v-for时， key是必须要有的 --&gt; 然而，要注意的是，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 props ： 123456&lt;my-component v-for="(item, index) in items" v-bind:item="item" v-bind:index="index" v-bind:key="item.id"&gt;&lt;/my-component&gt; 不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。 明确组件数据的来源能够使组件在其他场合重复使用 123456789101112131415161718192021222324252627&lt;!-- 下面是一个简单的todos list的完整例子 --&gt;&lt;div id="todo-list-example"&gt; &lt;form v-on:submit.prevent="addNewTodo"&gt; &lt;label for="new-todo"&gt;Add a todo&lt;/label&gt; &lt;input v-model="newTodoText" id="new-todo" placeholder="E.g. Feed the cat"&gt; &lt;button&gt; Add &lt;/button&gt; &lt;/form&gt; &lt;ul&gt; &lt;li is="todo-item" v-for="(todo, index) in todos" v-bind:key="todo.id" v-bind:title="todo.title" v-on:remove="todos.splice(index, 1)" &lt;/ul&gt;&lt;/div&gt;&lt;!--注意: 上面的 is="todo-item" 属性这种做法在使用DOM模板时十分必要，因为在&lt;ul&gt;元素内只有&lt;li&gt;元素会被看作有效内容这样做实现的鲜果与&lt;todo-item&gt;相同，但是可以避开一些潜在的浏览器解析错误查看DOM模板解析说明可以了解更多信息--&gt; 123456789101112131415161718192021222324252627282930313233343536// 注册一个组件 todo-itemVue.component('todo-item', &#123; template: '&lt;li&gt;&#123;&#123; title &#125;&#125; &lt;button @click="$emit('remove')&gt;Remove&lt;/button&gt;&lt;/li&gt;', props: ['title']&#125;)new Vue(&#123; el: '#todo-list-example', data: &#123; newTodoText: '', todos: [ &#123; id: 1, title: 'Do the dishes' &#125;, &#123; id: 2, title: 'Take out the trash' &#125;, &#123; id: 3, title: 'Mow the lawn' &#125; ], nextTodoId: 4 &#125;, methods: &#123; addNewTodo: function()&#123; this.todos.push(&#123; id: this.nextTodoId++, title: this.nextTodoText &#125;) this.newTodoText = '' &#125; &#125;&#125;)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[条件渲染]]></title>
    <url>%2F2019%2F03%2F29%2F%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[v-if v-if指令用于条件性地渲染 一块内容。这块内容只会在指令的表达式返回 truthy 值的时候被渲染 The directive v-if is used to conditionally render a block. The block will only be rendered if the directives expression returns a truthy value 1234567&lt;h1 v-if="awesome"&gt; Vue is awesome!&lt;/h1&gt;&lt;!-- 也可用 v-else 添加一个 else 块 --&gt;&lt;h1 v-if="awesome"&gt; Vue is awesome &lt;/h1&gt;&lt;h1 v-else&gt;Oh no&lt;/h1&gt; 在&lt;template&gt; 元素上条件分组(Conditional Groups with v-if on &lt;template&gt; ) 因为 v-if 是一个指令，所以必须将它添加到一个元素上(Because v-if is a directive, it has to be attached to a single element)。 但是如果想切换多个元素呢？—— 此时可以把一个 template 元素当做不可见的包裹元素，并在上面使用 v-if (In this case we can use v-if on a &lt;template&gt; element, which serves as an invisible wrapper)。最终的渲染结果将不包含 &lt;template&gt; 元素。 12345&lt;template v-if="ok"&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; Note: 最终的渲染结果，不会包含 &lt;template&gt; 元素。 v-else 你可以使用 v-else 指令来表示 v-if 的 else块： 1234567&lt;div v-if="Math.random() &gt; 0.5"&gt; Now you see me&lt;/div&gt;&lt;div v-else&gt; Now you don't&lt;/div&gt; v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素后面，否则它将不会被识别。 v-else-if [V2.1.0新增] v-else-if，顾名思义，充当 v-if 的“else-if块”，可以连续使用： 123456789101112&lt;div v-if="type === 'A'"&gt; A&lt;/div&gt;&lt;div v-else-if="type === 'B'"&gt; B&lt;/div&gt;&lt;div v-else-if="type === 'C'"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后 用key管理可复用的元素(Controlling Reusable Elements with key) Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染(Vue tries to render elements as efficiently as possible, often re-using them instead of rendering from scratch)。 在1中的做法，除了使Vue变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换： 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板(template)中使用了相同的元素(element)，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder。 但3中的做法也不总是符合实际需求，所以Vue提供了一种方式来表达”这两个元素时完全独立的，不要复用它们”。——只需添加一个具有唯一值的 key 特性(attribute)即可： 123456789&lt;template v-if="loginType === 'username'"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder="Enter your username" key="username-input"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder="Enter your email address" key="email-input"&gt;&lt;/template&gt; 现在，每次切换时，输入框都将被重新渲染。 注意：&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 特性(attributes)。 v-show 另外一个用于根据条件展示元素的选择是 v-show 指令。用法大致一样： 123&lt;h1 v-show="ok"&gt; Hello!&lt;/h1&gt; 与 v-if 不同的是，带有 v-show 的元素始终会被渲染并保留在DOM中 v-show 只是简单地切换元素的CSS属性 display v-show 不支持 template元素，也不支持 v-else v-if vs v-show v-if 是“真正”的条件渲染(conditional rendering)，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 是 惰性的 ：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 指令相对简单，不管初始条件时什么，元素总是会被渲染，并且只是简单地基于CSS进行切换。 一般，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。 v-show 适合非常频繁地切换情况；v-if 适合切换频率低的情况。 v-if 与 v-for 不推荐 同时使用 v-if 和 v-for ，请查阅风格指南以获取更多信息。 当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。请查阅 列表渲染指南 以获取详细信息。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Class与Style绑定]]></title>
    <url>%2F2019%2F03%2F29%2FClass%E4%B8%8EStyle%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[操作元素的 class列表 和 内联样式 是数据绑定的一个常见需求。因为他们都是特性(attributes)，所以我们可以用 v-bind 处理他们——只需要通过表达式计算出 字符串结果 即可。 不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js做了专门的增强。表达式结果除了 字符串 之外，还可以是 对象 或 数组 绑定HTML Class(Binding HTML Classes)对象语法(Object Syntax) 我们可以给 v-bind:class 传一个对象，以动态地切换 class 123&lt;div v-bind:class="&#123; active: isActive &#125;"&gt; ...&lt;/div&gt; 在1中的例子里，语法表示 active 这个class存在与否将取决于数据属性 isActive 的布尔值(The above syntax means the presence of the active class will be determined by the truth of the data property isActive) 你可以在对象中传入更多属性来动态切换多个class。此外， v-bind:class 指令还可以与普通的class属性共存 12345&lt;div class = "static" v-bind:class="&#123; active: isActive, 'text-danger': hasError &#125;"&gt; ...&lt;/div&gt; 1234data: &#123; isActive: true, hasError: false&#125; 结果渲染为： 123&lt;div class="static active"&gt; ...&lt;/div&gt; 当 isActive 或者 hasError 变化时， class列表将相应地更新(When isActive or hasError changes, the class list will be updated accordingly)。例如，如果 hasError 的值为true时，class列表将变为 static active text-danger 绑定的数据的对象不必内联定义在模板里： 123&lt;div v-bind:class="classObject"&gt; ...&lt;/div&gt; 123456data: &#123; classObject: &#123; active: true, 'text-danger': false &#125;&#125; 针对5，我们也可以在这里绑定一个返回对象的 计算属性 。这是一个常用且强大的模式： 123&lt;div v-bind:class="classObject"&gt; ...&lt;/div&gt; 123456789101112data: &#123; isActive: true, error: null&#125;,computed: &#123; classObject: function()&#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal' &#125; &#125;&#125; 数组语法(Array Syntax) 我们可以向 v-bind:class 传一个 数组 ，构成class列表： 123&lt;div v-bind:class="[activeClass, errorClass]"&gt; ...&lt;/div&gt; 1234data: &#123; activeClass: 'active', errorClass: 'text-danger'&#125; 最终渲染为： 123&lt;div class="active text-danger"&gt; ...&lt;/div&gt; 如果你想根据条件切换列表中的class，可以用三元表达式： 1234&lt;div v-bind:class="[isActive ? activeClass : '', errorClass]"&gt; ...&lt;/div&gt;&lt;!-- 这种写法将始终添加errorClass, 只在isActive为true时，才添加activeClass --&gt; 当有多个条件class时，上面这种写法有些繁琐，所以在数组语法中也可以使用对象语法： 123&lt;div v-bind:class="[&#123; active: isActive &#125;, errorClass]"&gt; ...&lt;/div&gt; 用在组件上(With Components) 当在一个自定义的组件上使用 class 特性时，这些类将被添加到该组件的根元素上面(When you use the class attribute on a custom component，those classes will be added to the component’s root element)。这个根元素上已经存在的类不会被覆盖(Existing classes on this root element will not be overwritten)。 1234// 例如，如果你声明了这个组件Vue.component('my-component', &#123; template: '&lt;p class="foo bar"&gt;Hi&lt;/p&gt;'&#125;) 12&lt;!-- 然后在使用它的时候添加一些 class --&gt;&lt;my-component class="baz boo"&gt; &lt;/my-component&gt; HTML将被渲染为： 123&lt;p class="foo bar baz boo"&gt; Hi&lt;/p&gt; 除了1中例子外，对于带数据绑定class同样适用： 123&lt;my-component v-bind:class="&#123; active: isActive &#125;"&gt; ...&lt;/my-component&gt; 当 isActive 为 truthy 时，HTML将被渲染成为： 123&lt;p class="foo bar active"&gt; Hi&lt;/p&gt; 绑定内联样式(Binding Inline Styles)对象语法(Object Syntax) v-bind:style 的对象语法十分直观。其中的CSS属性名(property names)可以用驼峰式(camelCase)或短横线分隔(kebab-case，记得用单引号括起来)来命名： 123&lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt; ...&lt;/div&gt; 1234data: &#123; activeColor: 'red', fontSize: 30&#125; 直接绑定到一个 样式对象 通常会更好，这会让模板更清晰： 123&lt;div v-bind:style="styleObject"&gt; ...&lt;/div&gt; 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 同样地，对象语法 常常结合 返回对象的 计算属性 使用。 数组语法(Array Syntax) v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上： 123&lt;div v-bind:style="[baseStyles, overridingStyles]"&gt; ...&lt;/div&gt; 自动添加前缀(Auto-prefixing) 当 v-bind:style 使用需要添加 浏览器引擎前缀 的CSS属性时，如 transform ，Vue.js会自动侦测并添相应的前缀。 多重值(Multiple Values) [V2.3.0+新增] 从2.3.0起，你可以为 style 绑定中的属性提供一个包含多个值得数组，常用于提供多个带前缀的值，例如： 1234567&lt;div :style="&#123; display: ['-webkit-box', '-ms-flexbox', 'flex'] &#125;"&gt; ...&lt;/div&gt;&lt;!-- 这样写只会渲染数组中最后一个被浏览器支持的值。 在本例中，如果浏览器支持不带浏览器前缀的flexbox, 那么就只会渲染 display: flex --&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算属性与侦听器]]></title>
    <url>%2F2019%2F03%2F28%2F%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E4%B8%8E%E4%BE%A6%E5%90%AC%E5%99%A8%2F</url>
    <content type="text"><![CDATA[计算属性(Computed Properties) 模板内的表达式非常便利，但是设计他们的初衷是用于简单运算 在模板中放入太多的逻辑会让模板过重且难以维护 123&lt;div id="example"&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/div&gt; 在2中，模板不再是简单的声明式逻辑。你必须看一段时间才能意思到，这里是想要显示变量 message 的翻转字符串。当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理——所以，对于任何复杂的逻辑，你都应当使用 计算属性 基础例子(Basic Example)123456&lt;div id="example"&gt; &lt;p&gt;Original message: "&#123;&#123; message &#125;&#125;"&lt;/p&gt; &lt;p&gt; Computed reversed message: "&#123;&#123; reversedMessage &#125;&#125;" &lt;/p&gt;&lt;/div&gt; 123456789101112131415var vm = new Vue(&#123; el: "#example", data: &#123; message: 'Hello' &#125;, computed:&#123; // 计算属性的getter. // English: a computed getter reversedMessage: function()&#123; // this 指向vm实例 // this points to the vm instance return this.message.split('').reverse().join(''); &#125; &#125;&#125;) 123Result:Original message: "Hello"Computed reversed message: "olleH" 在上面例子中，我们声明了一个计算属性 reversedMessage (Here we have declared a computed property reversedMessage )。我们提供的函数将用作属性 vm.reversedMessage 的getter函数(The function we provided will be used as the getter function for the property vm.reversedMessage)。 1234567console.log(vm.reversedMessage) // =&gt; 'olleH'vm.message = 'Goodbye'console.log(vm.reversedMessage) // =&gt; 'eybdooG'/**你可以打开浏览器的控制台，自行修改例子中的vm.vm.reversedMessage的值最终取决于vm.message的值*/ 你可以像绑定普通属性一样在模板中绑定计算属性(You can data-bind to computed properties in templates just like a normal property) Vue知道 vm.reversedMessage 依赖于 vm.message ，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。 而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。 计算属性缓存(Computed Caching) vs 方法(Methods) 我们可以通过在表达式中调用方法来达到同样的效果(We can achieve the same result by invoking a method in the expression)。 123&lt;p&gt; Reversed message: "&#123;&#123; reverseMessage() &#125;&#125;"&lt;/p&gt; 1234567// in component // 在组件中methods: &#123; reverseMessage: function()&#123; return this.message.split('').reverse().join(''); &#125;&#125; 我们可以将 同一函数 定义为 一个方法 而不是 一个计算属性 (Instead of a computed property, we can define the same function as a method instead)。这两种方式的最终结果确实是完全相同的(For the end result, the two approaches are indeed exactly the same) 然而，不同的是 计算属性是基于它们的响应式依赖进行缓存的( computed properties are cached based on their reactive dependencies) 。只在相关响应式依赖(reactive dependencies)发生改变时它们才会重新求值。这也意味着 只要message 还没有发生改变，多次访问reverseMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖： 12345computed: &#123; now: function()&#123; return Date.now() &#125;&#125; 相比计算属性，每当触发重新渲染时，调用方法将 总会 再次执行函数(In comparison, a method invocation will always run the function whenever a re-render happens) 123我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性(Computed) vs 侦听属性(Watch property) Vue.js提供了一种更加通用的方式来观察和响应Vue实例上的数据变动—— 侦听属性 (Vue does provide a more generic way to observe and react to data changes on a Vue instance: watch properties) 当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch ——特别是如果你之前使用过AngularJS 然而，通常更好的做法是使用计算属性而不是命令式 watch 回调(However it is often a better idea to use a computed property rather than an imperative watch callback) 123&lt;div id="demo"&gt; &#123;&#123; fullName &#125;&#125;&lt;/div&gt; 123456789101112131415161718var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; firstName: function(val)&#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function(val)&#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;)// 上面的代码是命令式且重复的(The above code is imperative and repetitive)// 将上面代码与计算属性的版本进行比较 123456789101112var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: "Foo", lastName: "Bar" &#125;, computed: &#123; fullName: function()&#123; return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 计算属性的setter(Computed Setter) 计算属性默认只有getter，不过在需要时你可以提供一个setter： 12345678910111213141516171819// ...computed: &#123; fullName: &#123; // getter get: function()&#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function(newValue)&#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;/** 现在再运行 vm.fullName = 'John Doe' 时，setter会被调用 vm.firstName 和 vm.lastName 也会相应地被更新*/ 侦听器(Watchers) 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器 当需要在数据变化时 执行异步 或 开销较大的操作 时，侦听器方式最有用 12345678910&lt;div id="watch-example"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model="question"&gt; &lt;/p&gt; &lt;p&gt; &#123;&#123; answer &#125;&#125; &lt;/p&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复提供这些功能以保持精简。 这也可以让你自由选择自己更熟悉的工具 --&gt;&lt;script src="https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js"&gt;&lt;/script&gt;&lt;script&gt; var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer util you ask a question' &#125;, // 侦听器 watch:&#123; // 如果 question 发生改变，这个函数就会执行 question: function(newQuestion, oldQuestion)&#123; this.answer = 'Waiting for you to stop typing...' this.debouncedGetAnswer() &#125; &#125;, // 钩子函数 created: function()&#123; // _.debounce 是一个通过Lodash限制操作频率的函数 // 在这个例子中，我们希望限制访问yesno.wtf/api的频率 // AJAX 请求直到用户输入完毕才会发出 // 想要了解更多关于 _.debounce的函数(以及其近亲 _.throttle)的知识 // 请参考： https://lodash.com/docs#debounce this.debouncedGetAnswer = _.debounce(this.getAnswer, 500) &#125;, // 方法 methods: &#123; getAnswer: function()&#123; if(this.question.indexOf('?') === -1 )&#123; this.answer = 'Questions usually contain a question mark.' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function(response)&#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function(error)&#123; vm.answer = 'Error~Could not reach the API ' + error &#125;) &#125; &#125; &#125;)&lt;/script&gt; 在2中的示例里，使用 watch 选项允许我们执行异步操作(访问一个API)，限制我们执行该操作的频率，并在我们得到最终结果之前，设置中间状态。这些都是计算属性无法做到的。 除了 watch 选项之外，您还可以使用命令式(imperative)的 vm.$watch API Vue中的watch监听数据变化及watch中各属性详解： 首先watch是一个对象 这个对象由键值对组成，键key就是要检测的属性，而值有以下三种情况： 函数：function(newValue, oldValue){ … } 用单引号包裹的函数名 包含选项(option)的对象，其中选项有三个如下： 123456789101112第一个——handler:其值是一个回调函数，即监听到变化时应该执行的函数。第二个——deep: 其值是true或false; 确认是否深入监听[一般监听时不能监听到对象属性值的变化]第三个——immediate: 其值是true或false；确认是否以当前的初始值执行handler函数watch: &#123; someProp: &#123; handler: function(newVal)&#123; ... &#125;, deep: true, // 普通的watch方法无法监听到 **对象内部属性** 的变化，此时就需要deep属性对对象进行深度监听。 immediate: true // 这样使用watch时有一个特点，就是当值第一次绑定时，不会执行监听函数，只有值发生改变时才会执行。如果我们需要在最初绑定值的时候也执行函数，则需要用到 immediate 属性。 &#125;&#125; 设置 deep: true如下例所示： 1234567891011121314151617181920eg:data: function()&#123; return &#123; docData: &#123; 'doc_id': 1, 'tp1_data': 'abc' &#125; &#125;&#125;,watch: &#123; docData: &#123; handler:function(newVal)&#123; this.change_number++ &#125;, deep: true &#125;&#125;/**设置deep: true可以监听到docData的所有属性，每个属性值发生变化时都会执行handler。*/ 如果只需要监听对象中的一个属性值，则可以做以下优化：使用 字符串 的形式 监听 对象属性。 123456789101112131415161718eg:data: function()&#123; return&#123; docData: &#123; 'doc_id': 1, 'tp1_data': 'abc' &#125; &#125;&#125;,watch: &#123; 'docData.doc_id':&#123; handler: function(newVal, oldVal)&#123; ...... &#125;, deep: true &#125; &#125;// 这样的做法只会给对象的某个特定的属性添加监听器 数组(一维、多维)的变化不需要通过深度监听，对象数组中对象的属性变化则需要deep深度监听 本文小结]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板语法]]></title>
    <url>%2F2019%2F03%2F28%2F%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Vue.js 使用了基于HTML的模板语法，允许开发者声明式地将DOM绑定在底层Vue实例的数据上。(Vue.js uses an HTML-based template syntax that allows you to declaratively bind the rendered DOM to the underlying Vue instance’s data) 所有Vue.js 的模板都是合法的HTML，所以能被遵循规范的浏览器和HTML解析器解析。(All Vue.js templates are valid HTML that can be parsed by spec-compliant browsers and HTML parsers) 在底层的实现上，Vue将模板编译成虚拟DOM渲染函数。(Under the hood, Vue compiles the templates into Virtual DOM render functions)，并结合响应系统，Vue能够智能地计算出最少需要重新渲染多少组件，并把DOM操作次数减到最少。(Combined with the reactivity system, Vue is able to intelligently figure out the minimal number of components to re-render and apply the minimal amount of DOM manipulations when the app state changes) 如果你熟悉虚拟DOM并且偏爱JavaScript的原始力量，你也可以不用模板，直接写渲染函数(render)函数 ，使用可选的JSX语法。 插值(Interpolations)文本(Text)插值 数据绑定最常见的形式就是使用 Mustache语法-双大括号 的文本插值。 1&lt;span&gt;Message: &#123;&#123; msg &#125;&#125;&lt;/span&gt; Mustache 标签将会被替代为对应数据对象上 msg 属性的值(The mustache tag will be replaced with the value of the msg property on the corresponding data object)。无论何时，绑定的数据对象上 msg 属性发生改变，插值处的内容都会更新(It will also be updated whenever the data objects’s msg property changes) 通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新(You can also perform one-time interpolations that do not update on data change by using the v-once directive)。但请留心这会影响到该节点上的其他数据绑定： 1&lt;span v-once&gt;这个将不会改变： &#123;&#123; msg &#125;&#125;&lt;/span&gt; 原始HTML(Raw HTML)插值 Mustache语法-双大括号会将数据解释为普通文本，而非HTML代码 为了输出真正的HTML，你需要使用 v-html 指令 12345&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt; Using v-html directives: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 12Using mustaches: &lt;span style=&quot;color: red&quot;&gt;This should be red.&lt;/span&gt;Using v-html directive: This should be red. 在2中的例子里，span 的内容将会替换为属性值 rawHtml ，直接作为HTML——这会忽略解析属性值中的数据绑定(The contents of the span will be replaced with the value of the rawHtml property, interpreted as plain HTML - data bindings are ignored) 注意，你不能使用 v-html 来构造模板部分，因为Vue不是基于字符串的模板引擎(Note that you cannot use v-html to compose template partials, because Vue isn’t a string-based templating engine)。相反对于用户界面，组件才更适合作为可重用和可组合的基本单位(Instead, components are preferred as the fundamental unit for UI reuse and composition)。 在站点上动态渲染的任意HTML可能会非常危险，因为它很容易导致XSS攻击。请只对可信内容使用HTML插值，绝不要对用户提供的内容使用HTML插值。(Dynamically rendering arbitrary HTML on your website can be very dangerous because it can easily lead to XSS vulnerabilities. Only use HTML interpolation on trusted content and never on user-provided content.) 特性(Attributes)插值 Mustaches 语法不能作用在HTML特性上(Mustaches cannot be used inside HTML attributes)。遇到这种情况，应该使用 v-bind 指令： 1&lt;div v-bind:id="dynamicId"&gt;&lt;/div&gt; 在布尔特性的情况下，它们的存在即暗示为 true ，v-bind 工作起来略有不同(In the case of boolean attributes, where their mere existence implies true ，v-bind works a little differently) 1&lt;button v-bind:disabled="isButtonDisabled"&gt;Button&lt;/button&gt; 如果2中 isButtonDisabled 的值是 null、undefined 或者 false，则disabled 特性甚至不会被包含在渲染出来的 &lt;button&gt;元素中(If isButtonDisabled has the value of null, undefined, or false, the disabledattribute will not even be included in the rendered &lt;button&gt; element)。 JavaScript表达式插值 迄今为止，在我们的模板中，我们一直都只绑定简单的属性键值(So far we’ve only been binding to simple property keys in our templates) 但实际上，对于所有的数据绑定，Vue.js 都提供了完全的JavaScript表达式支持(But Vue.js actually supports the full power of JavaScript expressions inside all data bindings) 1234&#123;&#123; number + 1 &#125;&#125;&#123;&#123; ok ? 'YES' : 'NO'&#125;&#125;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;div v-bind:id="'list-' + id"&gt;&lt;/div&gt; 这些表达式会在所属Vue实例的数据作用域下作为JavaScript被解析(These expressions will be evaluated as JavaScript in the data scope of the owner Vue instance) 有个限制就是，每个绑定都 只能包含单个表达式 (One restriction is that each binding can only contain one single expression)。所以下面的例子都不会生效。 12345&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125; &lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如Math 和 Date (Template expressions are sandboxed and only have access to a whitelist of globals such as Math and Date)。你不应该在模板表达式中试图访问用户定义的全局变量( You should not attempt to access user defined globals in template expressions)。 指令(Directives) 指令(Directives)是带有 v- 前缀的特殊特性(special attributes) 指令特性的值预期是 单个JavaScript表达式 ( v-for 是例外情况) 指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于DOM 1234&lt;p v-if="seen"&gt; 现在你可以看到我了&lt;/p&gt;&lt;!-- 这里，v-if 指令将根据表达式seen的值的真假来插入/移除&lt;p&gt;元素 参数(Arguments) 一些指令能够接收一个“参数”， 在指令名称之后以冒号表示 如 v-bind 指令可以用于响应式地更新HTML特性： 123&lt;a v-bind:href="url"&gt; ... &lt;/a&gt; 在2中，href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url的值绑定。 如 v-on 指令，它用于监听DOM事件 123&lt;a v-on:click="doSomething"&gt; ... &lt;/a&gt; 在4中，click 作为监听的事件名是参数 动态参数(Dynamic Arguments) [V2.6.0新增] 从2.6.0开始，可以用 方括号[] 括起来的JavaScript表达式作为一个指令的参数： 123&lt;a v-bind:[attributeName]="url"&gt; ... &lt;/a&gt; 在1中的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，结果会作为最终的参数来使用。 例如，如果你的Vue实例有一个 data 属性 attributeName ，其值为 href，那么这个绑定将等价于 v-bind:href 。 同样地，你可以使用动态参数作为一个动态的事件名绑定处理函数(Similarly, you can use dynamic arguments to bind a handler to a dynamic event name) 1234&lt;a v-on:[eventName]="doSomething"&gt; ... &lt;/a&gt;&lt;!-- 当eventName的值为focus时，v-on:[eventName]将等价于v-on:focus 对动态参数值的约束(Value Constraints) 动态参数预期会求出一个字符串，异常情况下值为 null 这个特殊的 null 值可以被显性地用于移除绑定 任何其它非字符串类型的值都将会触发一个警告 对动态参数表达式的约束(Expression Constraints) 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。 同样，在DOM中使用模板时，你需要回避大写键名 12345&lt;!-- 下面的代码就是无效的 --&gt;&lt;!-- 这会触发一个编译警告 --&gt;&lt;a v-bind:['foo' + bar]="value"&gt; ... &lt;/a&gt; 变通的方法是使用没有 空格 或 引号 的表达式，或者使用 计算属性(computed property) 替代这种复杂表达式。 如果你在DOM中使用模板(直接在一个HTML文件里撰写模板)，需要留意浏览器会把 特性名(Attribute Name) 全部强制转为小写: 1234&lt;!-- 在DOM中使用模板时这段代码会被转换为 v-bind:[someattr] --&gt;&lt;a v-bind:[someAttr]="value"&gt; ... &lt;/a&gt; 修饰符(Modifiers) 修饰符(Modifiers)是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊的方式绑定(Modifiers are special postfixes denoted by a dot, which indicate that a directive should be bound in some special way) 比如， .prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault() 123&lt;form v-on:submit.prevent="onSubmit"&gt; ...&lt;/form&gt; 在后续对 v-on 和 v-for 等功能的探索中，你会看到修饰符的其他例子 缩写(Shorthands) v- 前缀作为一种视觉提示，用来识别模板中Vue特定的特性(The v- prefix serves as a visual cue for identifying Vue-specific attributes in your templates) 当你在使用Vue.js为现有标签添加动态行为(dynamic behavior)时，v- 前缀很有帮助，然而，对于一些频繁用到的指令来说，就会感到繁琐。 在构建由Vue管理所有模板的 单页面应用程序(SPA - Single Page Application) 时，v-on 前缀也会变得没那么重要 综上，Vue就为 v-bind 和 v-on 这两个最常用的指令，提供了特定的简写。 v-bind缩写12345&lt;!-- 完整写法 --&gt;&lt;a v-bind:href="url"&gt; ... &lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href="url"&gt; ... &lt;/a&gt; v-on缩写12345&lt;!-- 完整写法 --&gt;&lt;a v-on:click="doSomething"&gt; ... &lt;/a&gt; &lt;!-- 缩写 --&gt;&lt;a @click="doSomething"&gt; ... &lt;/a&gt; 它们看起来可能与普通的 HTML 略有不同，但 : 与 @ 对于特性名来说都是合法字符，在所有支持 Vue 的浏览器都能被正确地解析。而且，它们不会出现在最终渲染的标记中。缩写语法是完全可选的，但随着你更深入地了解它们的作用，你会庆幸拥有它们。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue Instance]]></title>
    <url>%2F2019%2F03%2F22%2FVue-Instance%2F</url>
    <content type="text"><![CDATA[新建实例(Creating a Vue Instance) 每个Vue应用都是通过用 Vue 函数创建一个新的Vue实例开始的。 123var vm = new Vue(&#123; // 选项&#125;) 当创建一个Vue实例时，可以传入一个选项对象(options object)。而如何使用这些选项来创建你想要的行为，正是该文档的核心内容。完整的选项列表可参考 API文档。 一个Vue应用由一个通过 new Vue 创建的 根Vue实例(root Vue instance) ，以及可选的、嵌套的、可复用的组件树组成。(A Vue application consists of a root Vue instance created with new Vue , optionally organized into a tree of nested, reusable components) 12345678根实例└─ TodoList ├─ TodoItem │ ├─ DeleteTodoButton │ └─ EditTodoButton └─ TodoListFooter ├─ ClearTodosButton └─ TodoListStatistics 所有的Vue组件都是Vue实例，并且接受相同的选项对象(一些根实例特有的选项除外)(All Vue components are also Vue instance, and so accept the same options object [except for a few root-specific options]) 数据与方法(Data and Methods) 当一个Vue实例被创建时，它向Vue的 响应式系统(reactivity system) 中加入了其 data 对象中能找到的所有属性。 这些属性的值发生变化时，视图会匹配更新为新的值 12345678910111213141516171819// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个Vue实例中var vm = new Vue(&#123; data: data&#125;)// 获得这个实例上的属性// 返回源数据中对应的字段vm.a === data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// 反之亦然data.a = 3vm.a // =&gt; 3 只有当实例被创建时 data 中存在的属性才是 响应式(reactive) 的，才能在数据改变时，重新渲染视图。也就是说 如果你添加一个新的属性(property)，比如 123456789101112vm.b = 'hi'/**那么对b的改动将不会触发任何视图的更新。如果你知道你会在晚些时候，需要这个属性，但是一开始它为空或不存在，那么你仅需要设置一些初始值就可。*/data:&#123; newTodoText: '', visitCount: 0, hideCompletedTodos: false, todos: [], error: null&#125; 在1/2/3中唯一的例外是使用 Object.freeze() ，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。 1234567&lt;div id="app"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 foo 不会更新 --&gt; &lt;button v-on:click="foo = 'bazz'"&gt; Change it &lt;/button&gt;&lt;/div&gt; 12345678910var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;) 除了1/2/3/4详述的 数据属性(data properties) ，Vue实例还暴露了一些有用的实例属性和方法，它们都有前缀 $ ，以便与用户定义的属性区分开来。完整的实例属性和方法列表看参考 API文档 12345678910111213var data = &#123; a: 1&#125;var vm = new Vue(&#123; el: "#example", data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function(newValue, oldValue)&#123; // 这个回调将在 vm.a 变化后调用&#125;) 实例生命周期钩子(Instance Lifecycle Hooks) 每个Vue实例在被创建时都要经过一系列的初始化过程(a series of initialization steps) 这个过程包含 设置数据监听(set up data observation)、编译模板(compile the template)、将实例挂载到DOM(mount the instance to the DOM)、并在数据变化时更新DOM等(update the DOM when data changes) 同时在这个过程中也会运行一些叫做 生命周期钩子(Lifecycle Hooks) 的函数，给了用户在不同阶段添加自定义代码的机会。 123456789101112// 比如 `created` 钩子可以用来在一个实例被创建之后执行代码new Vue(&#123; data: &#123; a: 1 &#125;, // 用于在实例被创建之后执行代码 created: function()&#123; // *this 指向vm实例（以后出现 vm 都表示Vue实例 console.log('a is: ' + this.a ) &#125;&#125;)// =&gt; "a is: 1" 除了3提到的 created 钩子，还有 mounted 、 updated 和 destroyed 等会在实例生命周期的不同阶段被调用。 生命周期钩子的 this 上下文指向调用它的Vue实例(All lifecycle hooks are called with thier this context pointing to the Vue instance invoking it.) 非常重要的点如下 123456789Note: 不要在选项属性或回调函数上使用箭头函数(https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)(Don&apos;t use arrow functions on an options property or callback)。比如 `created: () =&gt; console.log(this.a)` 或 `vm.$watch(&apos;a&apos;, newValue =&gt; this.myMethod())`因为箭头函数并没有`this`, `this`会作为变量一直向上词法作用域查找，直到找到位置，经常导致 `Uncaught TypeError: Cannot read property of undefined` 或 `Uncaught TypeError: this.myMethod is not a function` 之类的错误。 生命周期图示]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue入门]]></title>
    <url>%2F2019%2F01%2F08%2Fvue%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基本定义在Vue.js的官方文档中是这样定义的： Vue是一套用于构建用户界面的渐进式框架(Vue is a progressive framework for building user interfaces) Vue被设计为可以自底而上逐层应用(Vue is designed from the ground up to be incrementally adoptable) Vue的核心库只关注视图层(The core library is focused on the view layer only) 核心功能一、声明式渲染(Declarative Rendering)Vue的核心是一个允许采用简洁模板语法来声明式地将数据渲染进DOM系统(A system that enables us to declaratively render data to the DOM using straightforward template syntax) 这里就引出了前端框架中最为常用的双向绑定，建立数据(可以是JavaScript Object，JSON，字符串或其他格式的数据)与DOM间的绑定。绑定的信息有以下几种： 文本插值(Text Interpolation) Example - 1: 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 123456var app = new Vue(&#123; el: "#app", data: &#123; message: "Hello Vue" &#125;&#125;) Example - 2: 1234&lt;div id="app2"&gt; &lt;!-- 时间过滤器 --&gt; &#123;&#123; dateDDD | formatDate &#125;&#125;&lt;/div&gt; 12345678910111213import &#123;formatDate&#125; from "../js/date.js"var app2 = new Vue(&#123; el: "#app2", data: &#123; dateDDD: new Date() &#125;, filters: &#123; formatDate( time )&#123; let date = new Date(time); return formatDate(date, 'yyyy-MM-dd hh:mm'); &#125; &#125;&#125;) 1234567891011121314151617181920212223/** 保存在js文件下的data.js文件 */export function formatDate(date, fmt) &#123; if (/(y+)/.test(fmt)) &#123; fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length)) &#125; let o = &#123; 'M+': date.getMonth() + 1, 'd+': date.getDate(), 'h+': date.getHours(), 'm+': date.getMinutes(), 's+': date.getSeconds() &#125; for (let k in o) &#123; if (new RegExp(`($&#123;k&#125;)`).test(fmt)) &#123; let str = o[k] + '' fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str)) &#125; &#125; return fmt&#125;function padLeftZero(str) &#123; return ('00' + str).substr(str.length)&#125; 元素特性(Element Attributes) 1234&lt;div id="app-2"&gt; &lt;span v-bind:title="message"&gt;鼠标悬停就可查看动态绑定的提示信息&lt;/span&gt; &lt;!--此处指令是将这个元素节点的title属性和Vue实例的message属性保持一致--&gt;&lt;/div&gt; 123456var app2 = new Vue(&#123; el: "#app-2", data: &#123; message: '页面加载于' + new Date().toLocaleString() &#125;&#125;) Note: 代码块中v-bind特性被称为指令(The v-bind attribute you are seeing is called a directive)；指令带有前缀v- 用来表示它们是Vue提供的特殊特性，会在渲染的DOM上应用特殊的响应式行为。 DOM结构(The structure of the DOM) Example - 1: 12345&lt;div id="app-3"&gt; &lt;p v-if="seen"&gt; 现在你看到我了 &lt;/p&gt;&lt;/div&gt; 123456var app3 = new Vue(&#123; el: "#app-3", data: &#123; seen: true &#125;&#125;) Example - 2: 12345&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910var app4 = new Vue(&#123; el: "#app-4", data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue.js' &#125;, &#123; text: '学习 牛项目' &#125; ] &#125;&#125;) 过渡效果 Vue提供了一个强大的过渡效果系统，可以在Vue 插入/更新/移除元素时自动应用 过渡效果。这里先按下不提。 事件监听器 为了让用户和你的应用进行交互，常用v-on 指令添加一个事件监听器 。通过该事件监听器 调用在Vue实例中定义的方法。 12345678&lt;div id="app-5"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;button v-on:click="reverseMessage"&gt; 逆转消息 &lt;/button&gt;&lt;/div&gt; 1234567891011var app5 = new Vue(&#123; el: "#app-5", data: &#123; message: 'Hello Vue.js' &#125;, methods: &#123; reverseMessage: function()&#123; this.message = this.message.split('').reverse().join(''); &#125; &#125;&#125;) Note: 在 reverseMessage 方法中，更新了应用的状态，但没有触碰DOM(Update the state of our app without touching the DOM)。所有的DOM操作都由Vue来处理，我们编写代码时只需关注逻辑层面即可。 表单输入 Vue提供了 v-model 指令，可轻松实现表单输入和应用状态之间的双向绑定(Makes two-way binding between form input and app state a breeze) 123456&lt;div id="app-6"&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt; 123456var app6 = new Vue(&#123; el: "#app-6", data: &#123; message: "Hello Vue" &#125;&#125;) 二、组件化应用构建(Composing with Components)组件系统是Vue的另一个重要概念，因为它是一种逻辑抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。如下图，几乎任意类型的应用界面都可以抽象为一个组件树： 组件定义在Vue里，一个组件本质上是一个拥有预定义选项的一个Vue实例。在Vue中注册组件很简单： 1234// 定义名为 todo-item 的新组件Vue.component('todo-item', &#123; template: '&lt;li&gt;这是一个待办项&lt;/li&gt;'&#125;) 现在可以用它构建另一个组件模板： 1234&lt;ol&gt; &lt;!-- 创建一个 todo-item 组件实例 --&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; 但是 上述做法会为每个待办项渲染同样的文本，这看起来并不炫酷。最好的做法是 应该能从父作用域将数据传到子组件才对。因此我们将修改一下组件的定义，使之能接受一个 prop ： 1234567891011&lt;div id="app-7"&gt; &lt;ol&gt; &lt;!--现在我们为每个 todo-item 提供 todo 对象，todo对象是变量，其内容是可变的。 同时我们需要为每个组件提供一个 "key"，稍后再作详细解释--&gt; &lt;todo-item v-for="item in groceryList" v-bind:todo="item" v-bind:key="item.id" &gt;&lt;/todo-item&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910111213141516171819Vue.component('todo-item', &#123; /** todo-item 组件现在接受一个 prop，类似于一个自定义特性 这个 prop 名为 todo */ props: ['todo'], template: '&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;'&#125;)var app7 = new Vue(&#123; el: '#app-7', data: &#123; groceryList: [ &#123; id: 0, text: '蔬菜' &#125;, &#123; id: 1, text: '奶酪' &#125;, &#123; id: 2, text: '土豆' &#125; ] &#125;&#125;) 尽管上面只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元，子单元通过 props 接口与父单元进行了良好的解耦(The child is reasonably well-decoupled from the parent via the props interface) 接下来的介绍中，我们可以进一步改进 &lt;todo-item&gt; 组件，提供更为复杂的模板和逻辑，而不影响到父单元。 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发更易管理。 在后续教程中，我们将详细介绍组件，此处有一个例子用来展示使用了组件的应用模板是什么样： 1234567&lt;div id="app"&gt; &lt;app-nav&gt;&lt;/app-nav&gt; &lt;app-view&gt; &lt;app-sidebar&gt;&lt;/app-sidebar&gt; &lt;app-content&gt;&lt;/app-content&gt; &lt;/app-view&gt;&lt;/div&gt; 组件与自定义元素自定义元素时Web规范的一部分，Vue组件非常类似自定义元素，正是因为Vue的组件语法部分参考了该规范。比如Vue组件实现了Slot API 与 is 特性。但两者还是有几个关键差别： Web Components 规范已经完成并通过，但未被所有浏览器原生实现。目前Safari 10.1+、Chrome 54+和Firefox 63+原生支持Web Components。相比之下，Vue组件不需要任何polyfill，并且在所有支持的浏览器(IE9 及更高版本)之下表现一致。必要时，Vue组件也可包装于原生自定义元素之内。 The Web Components Spec has been finalized, but is not natively implemented in every browser. In comparison, Vue components don’t require any polyfills and work consistently in all supported browsers(IE9 and above), When needed, Vue components can also be wrapped inside a native custom element. Vue组件提供了纯自定义元素所不具备的一些重要功能，最突出的是跨组件数据流、自定义事件通信以及构建工具集成。 Vue components provide important features that are not available in plain custom elements, most notably cross-component data flow, custom event communication and build tool integrations.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写文备注]]></title>
    <url>%2F2019%2F01%2F08%2F%E5%86%99%E6%96%87%E5%A4%87%E6%B3%A8%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20hello-world%2F</url>
    <content type="text"><![CDATA[本博客使用Hexo搭建完成~ 快速入门创建新文章1$ hexo new "My New Post" 启动本地服务1$ hexo server 生成静态文件1$ hexo generate 部署到远程服务器1$ hexo deploy 访问打开浏览器，输入 https://wangjefy.github.io/ 选择主题主题官网 Hexo 中添加本地图片 把主页配置文件 _config.yml 中将设置 post_asset_folder: true 在 hexo 目录下执行 npm install hexo-asset-image --save 创建新博文 hexo n &quot;aaa&quot; 生成博文，此时/source/_posts文件夹内除了 aaa.md 文件还有一个同名的文件夹 将要添加的图片 picA.jpg 放到这个文件夹中 通过 ![随意起名](aaa/picA.jpg) 即可引用]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
